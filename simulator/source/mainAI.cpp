#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>
#include <random>
#include <fstream>
#include <chrono>


#include "mainAI.hpp"

#ifdef READ_EPOCH_FILE
#include <dirent.h>
#include <cctype>
#include <algorithm>
#include <sys/stat.h>
#include <sys/types.h>
#endif

#ifdef DEBUG
#include<iostream>
#include<fstream>
#endif

std::chrono::system_clock::time_point  start; // 型は auto で可
using namespace std;

string weightString = "5031498850515000502250745076502450354985503350475030489649734991505050495010481350335107508549775056503649485064497950454854509150285028487551545079489350184894491147844889502249344966502751485118505950895052508150544768489047334992511548625058498649285069508750645070511550865015505349665007500250504899502450124984503550595019499751155004502450465077508249695085493050534873501250305083505350595016485049725013496550135032483849885092475550674911477950815126505549435054503748415113484749114502500749664913509050824908469047135023485350625046496447505087439949824929471650544986468151395053499250435082506143824736504447165050507747774360500550264978496850095066508951065003501250394962473750004802504550674974489250525036502349985061515649374929505049174916509050394861485051485001497750614886492849674731503748924916497950285115501350325060507149814672490947114965503748924949499448235052507050395003511249814968507249304980504650614847505449474959499150324995503050605020499250295016486249364988503849634806505650135072496250145058498650165064493550645008473048975057449550474947485250735049502450145055491849075013499049794838491150485018504650454734512746935058514650905002470047415084452750694872488450075023462750895094488150135076504045774702495247835008500246734592502349845060504351245083506549285021505550804644504149675049511850434887507850035041499750075088495150295082496349045036502250954963506350514976500349265008464448135035488549224992506351055098512750415087506046094919463749034982488449924944478150835084507750885085506049935151489650645033503847585051515449905029499850435004504750285034502649925021506850374903495649015063506250564998505150295078487550745000502950004909486350814551502950234586508950465079496650545005477250045006475147164943502849814967497450034769479150404942509451054889474050564568501649424847502949594689508549974933508451245075415747545080468749825014500945644962502950084950494150085071501748505003478949314673509050295073494049634922488148895105519550445159500049234925488949265050436948635035501050214953483746595078500849034918498549614932496449874787492450134293500848384823487347605074494646825106498450895113510749215047523649374856493349364701498149064968502448694969503047854955501250155005476350094881482850375131496348184951486849985162470746275010494849744996454443954997451349124923506950435121488848244829477345075046487547724744501349874896503349864749494346175075467750355056486946445081467050274776485849374987464951755094478250384995503743404791502746734979486846244398502850674978513850165064510350575106493650604741506850735108491949724970503149785179510149595080506650155019511850194948480950615044504050554845503948844918501148855002486450345124497351195133510251034585475549024932503749864951501450685006503350665064502550694970481349845057502750264759504949535014505750384995504349224992505950675073499450425050491649244964502750285126502450925058484048035032505050035105481349075019472150455040485950885066501350805004497948424873511645874818505849854995493750014867473844585031501351385085492949065048459549894848502150445091474351965033483150505091509445054657504745794979496948784290505550895018507448325062518251164796508349895149513150954961502249725010509051575202490749225066503749195069506950274850512850794995507749194965471148875098477349615212509750835064514150555144507948044962455650895077500651025051469051635043511551085126508550785030501051474966507548955083515750275062502451274967508550285040513750705090499850584931509450185050499949955041510750634813494950675024509349464937497950244383513950514768506050565133497250995046489351204892470548755021508050934995506649844841484350934905508850575033458250884652507250194780506450794814509352274985514150995098442149415083462550685020493543335093508050424894511950875120506051624886502851025087495950475137502250495120517749804931509350225003508951085020489650635096506950184998501947785031506949284965498751215140512751245117514951404741484048265006506348755079512948015150512451605136516751095028497550125029502550474883509050565039509350795117506550865107491951135084495249535136495350645132513950655081505251565010494849835087498550595037486850614988455450665105483151435114510650145121505448655095504847204720499850164936511951064963486749425084483650654938499449275178448150515029478150505050481951645162488950705200507546294918509548195130505747414700503649475145514950604918473451015034512850755131471950335039504050444928497049914990517850614905509050824975506650554972501650664965512747344900504650124951522951515164508251364898508050394643494448865051521649695014508849135002507450015121521250955092505249544992503851495140499750165011516150605001489551215092508650644996510450445073500549985081502249815075502249825007508549315014512149824776485749785109469650545003475350435155511849845099505748275006491347064661495450275026512651464887486647795103501551724879509447925280454751475059496650755173495250875130512751125005512143514952509348415033503546974304502049345032504150104695503949184991506050674901499249865006498749865113498649225031490449565070507050824905507651134992504349324946469750375013464949594896503951155126505949845099500447374782462347695058493150084974467951085049504451205070503249635050502249035007500948434981510050555107503250624966509950074953501550185032501850814939501948665078505150414959508950124925480150145080500450004783490050304629502350524659505350925120501750675039476450564972477746574970499949805038496349744768486550994989504649884863464150784403501949294808504750214623509351524966505151215052445048165068490250235033499446344852492150774863471249234771486348594795464448744971491848835143504947825033487950184843493648524963466148454905484547364908494048054632488146264790494248254779489549694899487048074578473748424653489945274885465347144749492748864933487048434624486947444935496149134481496149144886487948344909471948794914476749875015481749175002470350044797494350384953454750984819409646274939481449384889460047175020437950314939483249484867493548884963470946504883476045124317483348514865478449144748481945185004493249314731493644675043458449334826478749564717509148315028480748834963494845234543492444114852494550374443504050375035481550004959505750995014489650285009506049745097502349945085503949664802503850115009476750965059505150444795487746944866501248934890505350975072502150935047510750804753499847844962502449535014496547705021506150815082506750194896509348135038504750244615502649154998506650355002496951165004501150535041491450015089493950074734507450895032489650195031497149374944499150224952487849214984462050004900479550534994506849925054500149504992502948084826497150275179502950524816478347555025493750974994486247805021428550194942479550224976489350245121495150675124508942594833507244515042506550444664503550944969504047455019505950994889506351755040497150865022501549915056496849535074508352164829511550855044496550165017474849405081506850794971502650315035503650255057496745394933489749185146490249465067480450395092507550845071514450425153499849895029516947795070507951305050502650504992517150905204511050015058504649384961499948135014503750674974510651034945483451015085502150115089487550954815506150474889503151265048497550744967493550205022495247545004503351005088507048524782482550634940516249884913458150814645510750244899509050715024506450175001510651735091456348915166483350155083484545865000459550174943502450405010490650465056505849454975502550124791497849984887501150614812481951425061496550714966504746294517498347925032496050515009505151225143501049474646494647314923496449224984505148985103499049775126508550855075503850564857493049514815504350615089503550255086500850954996498449975030497851055013491149164994500551205025504550214960490346735024512950565018455546635143437550455012477950004993499049224982502047594973493348784869483649984909487850124830493447944965489750104915503049175115468350814972484849895075479450385098492451095138504544844926505448565021493645934378474847184858488445404703457949004634458445715164462447934535481644894498463947764694460846754923478546724868460642664857485748224921472048934875483546924334478747074646470143874719473944824837481545184996482045304818445648654762445546704853453548974868484643374762496448684733509646924653491848414703467150494978460548044915460948134658468148404787470244634818501249404921459146324700438248044737452347794753476747604582483944634847475845534227486947614825477946824241477044304768490149294724451042534891428946534606466846904917467647024814458246434754449842944454489643764753492342654318503150045084510251084956495948305089504548715165493250465067501548365065497551154856500051025010505449024942471849935119489749804970501350915062506349865117503045395040469050395068493451204996477050775090506850595092506350075077500450434976505147485085488149484994499550005016512750555097506349944954506450924984502649555027504950564958509149174795504050805145495648394721476351304626499249894644507450635032495349305038475250075063510348234938508850325031504947934981473751144994513049804813453350204608512450774972506249844757498250174928510651685048454749385129489551405131481844574920512349824902480045964373490149584893506750504906474851304551492547854962451650004820484949985132489341295104504247864696474050224949498949595135506748594653469148164845503345144963486251294977503148165013499549054656510748284779496948374536479248354993477149304976487150514643493151164966488250314979468949774890494147875008486549724948488046784811494449555140482845054893473749624736484150354872513447885017484650724928476948084508481047425024493749014931473848045000485850464660504747475003445948704732471949655151466650064795506849754955500043824663481850425074498747014474502850234991496650194932498149915007503050024976500749344886509548834834492650735051502050064952495147014856499148204869490750835058497450485120511251394662481249644964499749815013507048105041509050925087511550384986479850865044500150164776506550305025503651315079498950615066507350455111504450935041497550445035504550865068499450625039479248805038507950315002488649274988461450615091481650765075506649085028509349245018489346714651507249675009504750714917498248365032485751154980494248425093467250144985471550145084478650995102486151325059509243754750501047775035503848514500506350835076501551335079497151565096496849965026498649475090502949974776496350265034510448704954451247125079482251164925506451105069511351645130512046824883467047675054488250945018489351295132506250725117505650895227510950695021502547225042487750215048501549805027505951135081506750595051499051014969503150465154497751465053510049575031460150994973510449685052489850354573504848594943507050555122498750755070472150854863486748185038506550395054506849404640450750624886509250545016479051074558511149104916504450664802516852065093507551415084439747525121473750224995485646145023485850854991504349395091522449505103498049544931512749654963500050665045501149885006500547774863495048704900495250905017507151145104508550664744479047234941510449465012498349585081509651045129510550154951521049285116512349924416503448625088503350345141500350805020491249785018508250325074504150364862502149465066502350295034477748335002499549515070481848595128431850495155477150175105502450005053503847175084498948914875499250205068507950495095494248625109494950515044497847835062445250904811504150495082484451345084490450465128506943874869504148205060510345414653489347424732477148494948499147264911487846494727487550234783485549855006498648384835471148154645493345784776478950345027489049564972499850594674482746404969512946984749499645765060501549174887489748965000503348924841501648914682486549164736497850424759501750024880507048404849475847694890476448524963503449064878479648384695492549124894487648755010463645744983453948144689459149964916492747084995500549404909499744144561508549754968494448615177458544174874488051444852491748734774440349094936475149264895436148404984468349085032506141544776478547514889490548394140502049575013496350515169505450325019490748595117499649844956503350355037506249185014482549275060495149864938507350855039504849475086498446554996492948914959476351325000492150935073501749855088504849734960500750835054505946585057490350035026509050304998505650005054489350235165489650205010502050695103505650414941502150464748491650345075504449374753460849564876504449944826514951035052494750994956501550565011468544025064495149365061504747324876480650415003502451114856478751354365513149314820498150254737511350335046500951725072448648605037488651095000500844374972504449955074493149855041508349745084506350234913484050615079498749474901501947624948499151334969502350265068481750525137509249044491500046264968503749035024494546705056503750734989488349464900510850105057502650134718499450134821490349974922486450685003494650705071495650135121500948685019513650455037497150275090472149314937498749294941470349814941479049844962469048724986494949704962493248204943497247764594496748525031498748534984484945715054486850754916483148274946447950365125477348645031464949975048488949745054485943534512507346244997501650244598501249845051500750325032502749634892508649974963481149965012503549824883499348534952503248294898499550665087501650705091510050414664488647464895500848285013494147665028505350145071506949954972498549564932504050214793500449614944503649854937500450885011502450695019512048975061498249854820510551004997498951065041500750135051491750154969491948425052443950594985481149965024507849555056498949414959498949594714491049765028499550904872486347155021483851094956486548224992445050765003492750235007486150595042480850535041506945084874502148755022505648404566496549705020495949104966494047225029500148204909502850514982494648764991481748604975474949874965502050195055501050274992499046354853463748844995487849754909486350345035499649845065496349555005493550994957499848874999500449594973500650254985500150254907498149945016492950314918484548645038502149744936498849424860471049345057492850714847486049764664495650544689500049114935495450374931476549384931495247994853496949354945502048064843474250244944503948914811461850364533502548574829501450704761508850644817496950285081439647994974482449595044476843985030510950184923500449904988505551534759473950595139500149914985503545504929511849234793498150975120503350885011501550824512478149275009514047615005511247065015506451635120503650854986500049765014492550504703512648615153509750785117519051845012487050675013500851455043490750975173521550865100501050894958493945965071486250774946475147035141447250055087465949705222502449935004502749274893486746784506504750045211498350904768476448005039473449305022506148535129429150504953501650175086471151525139533150835181512442714696519348395062503547604558506651374974500350654932509850884993503550735087510250854831499547375051504951035015493550065143509251765058510650284618484049594839508550425131502247375082507251625158521051385172514048454817505650344629505950815145503950885109493250665088518552055023526849685207497549395035519950355034498850255076452847195172517950085137510949255070473149934983505150495094511850855078499847145025500049004931500550415159494651015036484749824955477452574972490447615078454049735086508050555010489549935155495951445132511347164682515648455088508549914300497249914949485649315060499648624800498750114985490748564938466149634996487549834902500750325037505949705011500346624816474647764980478449354935468749855026501550014974490750684810498249674958497448965019485749564973503849515034494248594930499848995024495149874897495747914839496950444880500950464910457949394907497549424953500050024415493049664674505450104964494049854914466350714960488244924948492349684839493748094921483049624967507948574984433950704562493450804708497649704678497850024889499251205028439745625064463549765057481245284981510448674907498648854784494651765100499550714744500248354585503747364932497350455049517050685071498849594716464348994847504348864826477746735030500450815123511848894864507949535043484349684451509648725116499750044923488850685046512349315024472249934998491850824761516850605021500449514954486647295059504649435142499450425068433150195033469851134965497849974969494646205090512448284767492749794927496750995017493346935115486051955126463849455064450749134945504149854808468449595198498549845043503944284651520945624986512149804578504950954980506050355116488351105041502750704873498247924886504148944935495851435058506151455178515251514544483648295071499350115106499848185145513450715036510750915046507050085100504550394667496950264969506949855098501551545058495650095093500749145077495250024969507750215057504650575113509649065037509550304939486848215057459650275010479150265066509349935099500846894926508045834759494849764990510950084908484447895031502850255000491045285051467751074938477150625083490249374957490251275166504343864781508147505076508247844501495847245057494250354799499449944962494848314996478248265004485648464857495751075013497249665039494445074873486449504898479149394985470650555112507950195002501148715193489950065028497449074919479449554979495450444871495949964718497749844820490550454905500448734975497449674929498649384751459250514964499848544837479249314562484349724761494449565027493649905007483750394920505246804815497149945003497348304601482849744784499348284967442349374565506848814545493650194724502049734807497349755000425447925033460549975008487842594881491548174800463048924940493449174828491348054831493847804876486549434942495749894970495448564510486149054662480747194894493245064930492048784923500048794876506849094936483848724893492648674957493948554738490848604910488748674948503048334901473648584653505249714897478749164838458245744932472049694925474949204953429448884897485049794873479449104905486646174767503344864554481449194887484447604957502747834874480649634924497946855054456749904991471449655051471147264918455449614948493741694598490146264878491249894181504250245026489350525017504150664953496946284908505148714943505550485077513550885052510350874642501647745056496749985002504144145050512950425082514650485041509750015087501050634819505850165041505550295005502951365036497751065062508449355072499450334820511250725091500651154986488747795039505150444940487649195100469450795033471950565061513249945039500049015127491847894764492350765038503050644855493848055085489951055057500347015105434551054939479750675094492351465172488751415183504145084835502147565068511448454540503147834822507750794985506549594900492849655060500549805077511350685068511049865063509347774967481148944992480350855059495649975125509050645170503151285131497250534975501747244902492650115065506050094991507150245009510550925019503751065006508651695079500149805040506649615000501451184939501650515002489750254562499249444928507550615119500750885020482749975009485749814927503349875064500149554863486750644551510749714837490051154438510449954865502950264965516951624997502250875138441748205117478849865033502845564978453447794756508149204757479242704868491048855004498349415056509049494977498749734797491449364952499549315023495544934925501050544965508949405027497250184881486350574660493350054951506349615025510751614932498749945168518650085095471649174804516549915003506350605040480748785042486849414764461847464860454549675129492549285084504649964819510749224859491246594680494749754933498451745015470444814915467751024867461145215168489150014920492050464952490350465129487450225100490343204805514847754920490646864454485049084913490349964595460646424314470745624822486749755021488748584720508848314504467948094526495647214885488144954806490848624715501247884982510849144967473547194496481849014759490048134917488549204971499548304905475847654864479548724961484747294877477649624781481847175056488248194890496848314906462749854719443747004740493348874881495145454846460546934597486849424948488248624776476244484961495547495084480044365044440349474986486751094752468149775098491449044939479044544711494042924870499845024405504450425211513650604923470748825010494048844924510551315023508451625113500645685035492349145065492250124970486750555100508150755065512549815188491450134821507646154997496249935061496450465056511250574975492550025072496451075089509949154959509551255147513351385025500651275052503450044698484450904700508849834897510051365185498750965040488049715162507647095041501649555111504650034984475450794872509150445014460951194592512049954936513751035139509953344887521150815023440848465137478150205174498144145033503349584997491846824851506746164962507950995083501850455107511251164561501846774894507549234941502348505138507050995040513250144991513150405140504249944710506349265042507650155020499051385024510950905053495750795078496550235079506950985061500350884941490848925041512050484906488350705080462250295012478950725033509249875079503647584982500748964797506150785020501350774997490846385049510651475001481948705059464651675058474050895135474652135071502550585152508945084805504748305064503547524623500149484893496349324864504348164963482150435053499750965048505550924474479546835094503849975057492048485060508650805097510850494867507749734927502649894734499849045061505049965082495150154951496350165052490250135046493649824860506149475075495449884977490047285009508650074921484448595035439850044983486650175024508249055007500148285092496247434846501950035067502650984815483249565037483050684832497046785060471950194948482749865047484951064969495650125106502244204718500646825017498046604415499248944925468547605042474948434921503350015023504850355045499146404854473848205048495750524898474350725077504850565097505349655022495649634983504147964939508749855043497450075021511150494995501349905100494350224940498248194965502349724973509849774820487949875024503547994791490650224760500349514956503149905059489350435004487550484942461046774885501849935029506447204789476049834925503349144824454849994460506248794884500049574819507350224854496450545041463447855041465949894971479944174908488646104725496247675011476149254973490349464931501349274604458047974916486146874896493646695109500049304986501849685059489950194829496249234871498151374942496049454920483448604890497251664785498349684981483949974780496548834877488949474733464247804981474850204759493747525008470648954765460550074956497347234914494849385058494847584838477049054795498149264351457647724971462450845073496545275027409848554945471548934864485349904861463549894928495741594658494844245008505449044707494848014795498549324964500950195003510550704994505150314573485847234946490248155048485545684941500850264952504948965106495448055036497749354877497250004982494051054949500150024843481849534956480649495000486449504669498348404973482149694988472348724945502150164847486449565001462849474934493749605015501848975007489745094993481148574757483249054836491647894686483647514927497051084838486048885099457449534878463649534901482550024859477249435053505743834860490047134906500047214322471943954793455645224776471946364809473751374822481143234660439448094852441147114755431048124735478247914925482049014480462046824728493148844652486049194683465746244601465647544643495146414737463647134594477444154979463747224600476346495024475748144793469345134182475848724660481347524322484849314742457846844860445648004624451344584656455847224687483848944584446847364812463546844629431546394536480145004550473948894166468046134843484448054806424544444627489448334721467044114844470549534747457148424901500049055037495648944477491447824661462347124932495546534747496547714762488347644849510548814887491449744653478146744856484348794858488249694851482349484838491151414877477747464961482550444751502448434833447849524892488847574752482843324880465648194722459548274847488746844536479948864953490349554168486649455027491647904760466247014865462151524895456045564864447347954867472949224933475347964617470345644994482540404619506244284963479249204340501347675020498450495072498850885092509650424577477347284979499948515018499347015001506750595032505850344916502149424889500750094640499250455074502950434999501350005035502350364984499649225064491949834883502850575098503650634990490949305049499750654990489649615002456149834950482850165078503049115012504848994970489847824785500249664947503749124836465847714995492751054961489147525028467450694906483050125040473250505154490850615130508544754769501348495068500648204677483149674801496350364977481247954844473044045033450048664886493748884791482548554922462947504766487949054945490749004710488549534815489349524709477947954835486349184626492449194776471249884774478250154706486949654895479449314802476949264812500547514640489449414718473449134738487148574874485650014834484547914928426542774699490647004772482947364602469148464705493548414576466649414272485448884558485048654919460251154822498648654875419346265076451848694886429543204925471149334965494550525046499549474572476247804988492947815031483847705046498349774941493349655069507748864794482948924595500948944954496148574884497950054909493749674890505448645042474049894945500649984998492050125065486046934911497649554840481849104924464948884840482950054996495648984938498648384910489545784823492748944926492549924913485246954936487250324920488046375017440250164751501049804832467349865076475050005022487944934509499545155084507148004478496449605015511449735072507948524685467148444681496148964977500546774941493650055010506849934824503050035015503451384817501048685020497050054978490050324950495150474941490749814881489350304468502850424975498650105011472750154910496051274983458347875144477050444958503850495051503149694862504147854958493146194653479348354850497348994684503549955066491850395015492646255032445449134995498249985034462150535021497150105038497046214886506348255024505648244266508150915099511449865110506046674882462749255055493050425034461750865139508051005096507950065015498650265036507747325122504651105096504850635010511751105029512050515108508850514946498350085098500051495063510650524981489250635090505250254936491650864716505450564935501650945105495350385030478350414994489347855003502351005017507249074761482050524888504349914931468151104529511650114707506650654775514850884912501751345041449248845097470650585073476744715080508050755129516650294586509548754958507750125122505547895131508850195113507551215109515450435129491851094612501650635088504750825103503550965053496151225019497650655098506549924907500051515089507650945134474547955063500050595043490448715099465050875098498051245095510549435043499548685044495449794842493051195113503450804919487948185077508451384966505245185079478451634982482450525021475551725026493550755143507746974795505947845112509548464507504351105058506050574659490249194904503249155090508349445102512250885091508850535099519349384997502350394784499049695041505450215112503851655052502249365022508950905065493750155087507849895071503050685111489248635009500250645100471650075019481850845053478750965103503049505095505048865028504047664760499449915058504450904823511747175030474950084878494948915093448251304892503850685038479951775109506650595072506644454889502448185038506449364568507950995117510546074715484849945099497550495013474351195128511751625159511550564988493749755035501947735028507650615154503751015052509750145145494850915096506951074966504148605112500051285012507450364888479750395018510950484952494650614812512050424859511451185141499850925051491951105026487847615020509750815093509549324775476150684939511649564974480452314444512850305046509251464914510350564956505551295120437048495109482350585146498044665041505450304740493349644914509149125166516348325121510550794991519950235002505350035185496249684845510351295063506950375050499751615063505049175055506651105101492350315030508650295098505950945022472946345116505051094885490449755082432250164991484050875108502150404992498648064858496346855075489650645067511049634698483245855012490552244931496947365156437852524977502550925050500551704966493750575050505445154744513946975076502649824938508250764648495049155042513449405058499347365087518451225090512951005107507450115023498350444740509851195079507850685046501551465156504751405086504348755126503250745134511250555118499551095069490148745084509850995024495349965091468651425079495150625111512649705031506447565098496648574664503151125021500050964992474947715039487751085046498945005045463851034982489351005091475751784969484651125163509743944909507047375092505149724531503747554952480149175072487050585053505150655044505551065090506649834906496949325005499447635022499150745059505450865036512850275037518050114984521551164966504151405063504050605069510250534840479950194984500950024871490650424695503050434704507950865060493949995026493950294855483347725014500049745063513648004766473850844823505150744752478350134526506048844855500151184777523250874920501251155050450348595066487450875052477745214617435444844454461146624854470151134539481448704663489546254428478445394819460045254291481648094818474246854496467348004652465947394741460344374661467446504523466546844554448648214570425745534591489847084569447744924639405047574582422447284624467547214631462144354785448645124556457145644793461147904618454244234710445649834589462646824745411646164861434946894563469548224713484846584645467941424304474646104662439545633420485746854449478947044977465046505026495850085058483148994935503047474631484649034746477148574887498747014909501650184892479948954805497248354952472646254699476148284838493548775013448746694804487149144942470347914784440048844865482848274846495848744983485350394744477045024601479149144665492548924471509247975006490146134779500046004749463648354663500048344892430749145107451945925090512943085080488548424703479248384288471646824767473947474712484448964758465148394819486344724609467546534694466147004593478348154911477648194792491447004430476846514888475647134662499643284705477446804632482346214510461947484568444447684618462547444560486147124281476647344822474947744533471646104832444745524770486549344730475147794798474548504885499751814515367848414194467449634769466146734432461448734430476548044841405445874679471545904937446841424925488949494979488047304923504849784849476949894916485949884758476449924691483949484998499150165060488750024917492949074980514248124937480747144773484049904954498049975018470949174964506349734609457346854990436650054855487849854862497846185059485445045155469248704874476549694945503149954995458147424848485348754832501444934867444749024659469849674914503050004984477849565008497043274359493945444950509746084422500850524865493046435060509050645047503950464989501149285082510250264600505649294986503949444973502450015026500250105066494150175022503650284865502649815057501350605073489850375014516250664862476548985030449150505001473850445056509549195024504648755058500647074859497950335008497850934809478147905004505649595040492448595081450150325006484350795006475550665133501050715107503543224728511847824982500648734483489148004952468548584844498948445020501547795036477347404969488046654812499248834902492750024777497649674736493348645013483348964878488346154961494549744937485248744644471249444937493148274755463849544451491149534703490450584920472349834861486948034797464343394819502748285087493548454697455849075078496248874795425749914439499248264554493348954462503948144472490249615009437948794826464150044929456344544996499445785093506551225012503850194978488649795165500050464919500850744891503248745012494650914995499850645051485650015108486950865022514150275045496450795064474249895047502050354988492447915042435650304953493550575001509349475076487347615051494149754880489850015041490750495189491047084969461650604973501347425060453949704896487950385034456449885054501850865073505442984871513246715051500948514379496146955022500850415017504449945045527948315000481750284737486448804910494149684943496550495056498450614892504950725034489750405014509250565010496149954868467247505015493649484907480148844978470249484961490650644975494249445031501349534952499647534733484350195006506851115037487147975043499150554914488447435028459950534993480250544997464950425135481749035066501345574661508047755085500648214523476548504680490748884779485547474950466748614770457147614790492148974758493248424726486148164745483948764938462047584588467945504618474948794668474349714603464948194905466545784904478850614392474545854565478546814643471749454650481048494500481746524651475450624865500442824666468448704776494446254763466350094616488246374476492347094577500049824807495947454945424547984701497748504720481243225042512550815105512850285112510450015063504150024967499850564945508550295072506551905032497551005094499850805127498850404894516249155063502051075002484649515103500051145083504149155130448350944998497250325053506649595036507448675059514247934837505651025045505652284925466046615067479651085124505846465071440450934985490351325101477051425221500051555148514142704913508249595091505050044576508851225149513950915081503150125021503551174953507451415072507250595076512051105058500850305070512050655118494850444949516350585073502651095105471549675090507150814960478449935093464151105045491451195103511049765075508949385027507550064821500450415092509451114909494346245066506151495037514948245136462650625035490050885119498751325143484550555148511043354747503847555053503349604443506051175083509750895222493949984930498749325001507451305027506650965048508950925019509450875059503551235012507749935084511451055034514649784897486550815096506950554861496050864733508450734802504250225060497150925030477849934941466147255045505050124946514449654826481950934943508750934852482850684665508350134855507650854692510951634980510151315078459247815100477051255056493845325061515550795099511150225057496950664621503449885065506450105068505151705070504050365126499950215097498150725046510650735058503051095026507748275055500150915110488949685072466150514969494650835119508050205105504548905067504548404730503850025057499750794847489048675047507250905032492447225106467550744996480451035142513951115220494851295137507745974777510647015086510849034635508751114988498550015109511050624882498850474977510350935100503751045059510851215157518850395102505750884850508951165157502851185132469849225109509050845051487347515113457650705020492650995034509650485070506849355042511746534558502850275101504851234914487647815081481551205096504847645100478551335014500950795088492451355212507951225116511446074771514348135096511950004676504449855084497350165049505450055017503050615089501350345040503950235014505450915072502950824838502950045072498750574981504649574718493450185036509749174842488249974662499850144764506850455088500550665040473050324972470947365009501150685035504449444784486550204928511049845019485750254633505650704795507449895000509451214939505850885054451447174998479351085046482044624986504749824996495749564934516851754901503751274944482949684978504951104805504649775080490949584889505549884988481050215063474044714894494650654969487348585052465250874887473649644891496149054928494947305057499348914689485149465006496949284839447248275011487650195112492146415072475850835049481349654939492650145081503450425124498944954555503246735005501349214423503150275000490550944773497250645207491650674984495849085206487947704870532252004944497050754695508250994937505250005056515046285131490650484838512247155040432949935042496549595190518349385156504849195094485452404893522851635292510448265074495648985110500650915183491847625237459550485013502551165043482751565299490651665059504243535168502650605048489544364742494749124944495245974967482050054992494949284920500049444932511250604963486848925010490848675049494750134955505350234666492149754913497448514636495549434757489148814729494049905014492449214930470549484987464846415000501451104914488247994821483049765066511049254744455749254462508448444816503549544726499549764798499149925008432946414994457149574910471444244988493750194668497850885037499450385127489851975073507650554947516649854997487649944943504150755030498350285063470548954943506051374989487050375016430951075032477151135139504449895066493245414870493248344810487647944876511350884750475846734948503450304924499148654984427250254738453849655052478750465104498250135111505044844692495846835001500347074463498249694966500349785106482949645045494650814969497149735015500849565039501349675079502749155019483950964938502750204947501249904846488549845018449650504879485550665061500850095032480847684959503046834663486249124945487049894932464847265025489650874923509947744962458149844864481549584980522849815135477850105037498843144826497846004980491148584577500548425015499450325065500249794967498449875038498650094904507250364911498349654998510350444994502249814749503549964987501049104751486950094630498950294812506950975039493750675003487650324970497747854946500049764997513349144883490050214887506450024858481649704371509750254968499049864881513650924847507051055007451548665090467850554978485745894767498748954785487048234920461448264804438948904771500047834983469246634302489746894868481349014890478446204781497048044618458248064728433650404649467847344803490647514786474446704722486746744495458346844805500049324638447046214844447647824941461339284751455247584634441247724939448347784662473548444937486141794621473042034761470244873921500249534976492249984943499650345052495450414990515049425054495550054875506850465043500150734936485148645042510650785108479248734961467550515029474850685027502949515166498146734986489146684732501649934977494350564906494745875062480950235000494347515027457950395014491950235051479650665074484350005081502543714898505146195056504249144483497350044945500449364936494550314865503150774850496750304940493451205045510450325014504049294912498350234915503449144934495849574373511449644888498750034969497350745130488949894985481448604947476651475114515049504788456850084766504450984965478750064838503749024820500250264962507248354706491350935019467751095008455750385099474344545010495949105049499650544984490249945002488549085123498250075087507749855080501150595030485648995086507248864940490345595069484850634982478751395064499549345001488246754995499048814903501349744817493849494698490149214985493050724966488047884989428350474979489550415007480749825110501850765145499346734791501549065012500247614345503949875040499651295026501150315023498449035048498350124862504050025000496351035020491548975063502650464921493248115080450350485036487550615094508450055042503448224957493347094812499049965070503650384959468747755018489151334978485547705084479450744917495350895098480651155255485650735084504145634814507145795106501746164384500949735020510050104978507650355089506450224955500950055042514750355036498649615008494650274949505449514786492749554713501649534676503051354971496950695010475750045204482247304946497450125101507047944704475050604972504749384843484249974511501850134889501550644792513950134957504250464998465048365011477550445076489445515028495850565099503750015070502750235083495649684995501250365040497951064928486248095116503950064961493249395003439850344991473949845055508049295040499646885123505249874819499450604982501550274868473948935035475951584952495046985022455951594998471850375075499051065072483450625033506545594836513847825064497049054586496249805045503350114952488149774966484949404926499049534971495349384963472846974961491649415011486049044985451949494912485649434980499649264945501749345025500647034510496849075000495351514692479547224953476949984868480846445038456349864950487349064939498349784940498549515092499142474822501248235006498247274494507551065045524050145176515351405015504748225083506351065064502350154924496250055114503850354964479351124512508350704763504051055069500550045092503151234868501448775053507850155047506448905006501150694962509349324715474351694549520750084840505750994807519650484895507150785094475449595177481150505055466944605034500049445047506250505070491650174810503250685054501450424976494048135046497949795029498249605035451250245051492250665036508049695023504948585022502748674701499850104997493149854998501349425053484449814949498046705081455850935096478050025027485050195161485250785099502843054816507648594983498248124566496849824971500150795021494649855027501650114931500150804749496548335120505449964975486149375083469150284986476150525002500249255042499248004958502246524527504750155055490850954662499248605020498550954960479847214965420750374966490450135030484050415083497350775025505741494846517346915075502545884533502651115032506650434885494949025041511151525007505349654767485050044971510048694891491050034592498351614863503649475222499450775004504749605034490147234868512850644975515451524807485750674751506850294802438651044447495850004921510651034844498751374927504050755121418148275110473151204982467243405034502950825074495550004786508150085067496150395031482248085078507550105001485748315001458650774964469550335041507049575075496148094988493349864811493150635053511550244984475547105004473950564960487546865024467251594957503850375045482051515010495550725083510645534718505848135035501647864260498050535015488649454792495750974939497051065032484648625067500649925009481051345052477351114935482447975008505850165046502548255038478146054507494150454985496649744895465547244970464551384824476943695129473550174975483849844802462950065095507650705167503544394746501047365015511047844437500250875039502349955044497450165011508548274830478850005047500348644860496949474570508550284803496448355001492148855063481449955044462248505011503551815082506648394855465850494933509649164745468350274611499349184861501650274697511152614966511750785055453246905014464649474994474746755042500950075010501651255045502651025046489548045059507350255066492550065062458650695143464151135093507249345052502647765064499549204727499050004990505150514855485945745059490051874965498447075084456251144957480050185085474751785036495950535129509444034727510446575095505148584340490449434889492949155021495549545019474849204954503349435058469149844910440549704977459349495119496648414830485147424978495946024745492948314891499849204567483145694952484448684873483245835057425949534890488949195001473949835075487250025041494242844840491147904946493848594389499948315023506550235004503448524812481250555011499749584695479049514664501750124739501350255010493749765053476950064945455847444983497049795010504048044710476749794840504049454864455949744551496649414783496749904684505150624837503550875058434448205037471649715021489343944920477247005000471550404914473546244613503047264763487549174976471250684619468450075018497448264886488947864888468449054642497849014757483448044650493345324772471351674670492043684888447350344656472848325131459547954904463848384964487437244721494445044856501944284429504750685103491550755090487648174956501050234931496047495025470650265006474650765106508749215006501045605047490048684848496349605106503451594937470746455028472950245002504747955021459850634958461950405033493450815011493150015083506044424775509346175030503548764680502850454999513550884900477950845016512649554686488250594489510850244891508750305083498951125023487251235063488046054972497549644978504350444782474550424850506450004794462251374480503050144745504850814865516451034977506751085018466548725055469450395041496844045033490851125057470547955042505850255046485949305058440650965072489450474974508649465066497647505075493447154785492050475149499750855110460944865042484751074986485646825129434550715040464450775047493251025065502649715101507045434725507847645123496947914354498050415033480248594989495449025042495749274969448150905038469350375084502648885033490248394992494349384668494648634990503350214778473046214985495850794958494748295016453950004848498150164969463350894959486949625043504042584905505547064973495647544268504350454796504550665042505249654863472350494649503950584902510351145109500250535041499850894979484347695007500851165095516548694810483351104861505850254885486050784673502549424978506950594952511751484945507151435044429249195077480650385026464443844976495748374905497149914891502048694998453150154949484249835001506349184959489948834871488649184762490050375000497850084840477747304990498450784985482746955015440749774931469949694966479150375125484949765104501745114781511047755001500347934493483246104831474748474995442344824963428947994588455248554889476446704875491445904899468249024924479647944877487647034704509848834877493948474811481949305005406549174909482248164859415050045027493247984873483442324221487642994760494246014322485049964917477148414683481748554562504548724781493249355005471247244978466649794647449447314799483749884743482647694249457749415100488547854563412148424344497348804736486249975169491251524918492949094838481748414976467148914677475841165023502750574993483348155089441049625043472350605007510749475052495749275033500746814709495751005002499750334896492146885039498650625016482146945086459851184982492250355020461850535222495850665127511044464872512748145030497950364293499550004890458449265010466450624926455149835042506649964949497748104923491246834764491750195029503750445000490847475001493351065022507447145007454250214974488250624997436351084966491350485108507944524792491746035006495246744489502449474830487749854717503849674698505850985112498250355058487250894949491547844994496350995040502249224868451849984908507449224966469151224575503250114744502449894951511849655055499451315042452647485047464050495046474344384980456949364985480649945044475350244987496049335034486647974889488849864764498948755026507049614348495048274973496350314827468847595109446950534972477149834963485649375028477749425001505643294894501747765017495850194583482348824724404949714888464047264934483248294697485648104921473941824484474748364931489548514468449144874825441648064935480244185077435749444566492948004885450549774795463148164881487345184554512344154763479949194667486047494892476249884474494849804881477349095023458948105184467244644809484447545077481546524688451748964689494748134987463950674389490244964755477350264631503348854627479549454819421344904940447248154837481842565014452250074930483650604934504749675002501748844985500647944833495449645067492050014838485447895051503250544905502647545138476150994982476450395019504450595147501150495112499245874706514847565058502148064481454746434690415148374638455843784689469544704630449342834145469645324467481744534570443142904521500847234431457443604746428146374371453246754489436947524522438446764774466841644267451742584652467639474230500549174808501850355042495150284967491150255052467347804998501350334949500349474728470750174833503550774854484250624507505850124995503550294796507049894866500950975054454948195048490950185046472143634974455349854966505049665015496347134992505346864841487451104943485851684887484548454950487149064924490345395031475451015008471750145017493550085105490250205053504542994845500647255044490150924573477948074675481946754844486648054830454942694437454147054846482949604767466247034885452746424717475344484836413548444765486947704826450549554881469047974922473341664602478743164788478943864016503650985053496950075072488449515080465947555039497450775056503849154875492950574933514251085038484350984581507949714986504850134858515551264974508550695049450346635039473150565059476647995037504549895119506246205120491448834793498050325080503250854794484149185087473050695083498748155089464551205017498050455058463050315116491049845068507944624961506647035026511551144471504649485123505148855089490448724782498949744981497548844908491346975052467250475094494147315126447451184981487050545071472750735120492850895129506743534774506047875083504949384673492348924895475549284750472048244903495849505000498246024692478048484961498749384810466949714391503348434928487449374811490449544838495850334918453847314908448749614875486042535024502648035063497750514866488250644986501550674992480247105033493151055097492147635049450550595051481550705017505250355079487349865066502145954850510247625089495746094381498547975044505946684573495450055002502651264870477747535012486749324932492946505085454250684971484250075006488651665024492550375036494843694903503346695061496247554403481148934910453043454736485448484876467946144323447949494709487746994641457949024356485349084738493447244700488749144409483349144873450145714685461148834648452339605012496549844625497849125063514949304809469747494992464449465027464946885053468750805004493349884981467050835172493950905062497744704988496247875038500949874608495647954664500050124932501850754869483348204966491350645041476446705012430750704932476550225057484749154879496049575102500044894642501245564914499045894695477045504871470247114677491145254254455947364660479046584509475746094250489447654542484049135016483649484827485348734655428845394715468448574772463941024715484048204700473945944679455144904784473848474697467347424670413746214709475547504697450347704801460346614720480844184726477543354881467944124287495649544881491649634788468446265003481249394919484846614964457450004883484850054996465350554936477249335000497744254710498544575007497848624290497650825019489348154844462549754858496048964901492849464478510049204884497049274742503950264808502450175027463849895041484050004924466943914985506950364884486847254958496950814841489547804988467351194962476250334951516450625356496650384963503641984809508247115043499847294368500150194613475447384948479650304944497748044996452050164909477049755005508950225037484450545101500343674677512746255006505350944755503548424790469450414739498250454955488650944702502549374577506449614990508950724846500651475028446747494959477951075033482745524858479047854871471250294818462542704815445449904808470649004942471250385096488151164839475843304359489446984823480845664256478946724650443248314589469745334629423949174837481248174957497449084963496947765052475140823871485543704889501340724605472846734568486448084689440347464191496548414552467048614150488148574615471446514528420646514820432247414875436540935006473150604946494146344993444050865029489350005007478651545079493350935057505044344859501846985021503948004521487648765016479242154994470749624460466648784909484347874872492548624883494742584769497846005005504546524630504650475109434450734680512248604646504450704911511550474958512851925044446747295077477651045029479945594972494345255066457049824659481150374983482249834858477549015051506841254692501545545062491146164442491144584990475749264571475149214968483749535077498148214882496239324894495845144991483545214237467648114638478949414595464848114624477449604475474646594774418046684602388045664790411744165047462950884917488850515125498151485074496750635143508845904714510647285107513549014481452348134473418246094700433346724548445748674517461338624261454240764690439543364114503750334941505250364726514651375044511051365133447549805102480450814995474043564932454249144788443450065025489348834952494243935034502746564904506949624117481749304628430648444660476448384835496745154157487042474765484546294085502050344761507150734937497350685036438148015029476850215001468043775005479250765015495050105054508546584868497748485012487547384338479449784826472147504775479941034547485947484911450844404477506851414882502751395139446849095156474051165106504047415060500651115092509645724922518448175062493446494479489450204930495545714652491048134899484146304398502250605070471245285061478850324998479344845092513844684838504248175131508049574362504145344801503948295008499948184560442542544726464645564421415243564771488846454814496048314283504945975137509147264623468546904486423045265001506746894500500348554396480839784431";

vector<vector<double> > mulMatrix(vector<vector<double> > a,vector<vector<double> > b)
{
	int r1 = a.size();
	int c1 = a[0].size();
	int r2 = b.size();
	int c2 = b[0].size();

	cerr << c1 << ":" << r1 << ":" << c2 << ":" << r2 << endl;

	while (c1!=r2)
	{
		cerr << "Error!";
		cin >> c1;
	}

	cerr << "1" << endl;

	vector<vector<double> > result;
	result.resize(r1);
	for(int i = 0; i < r1; i++){
		result[i].resize(c2);
	}

	cerr << "2" << endl;

	// Initializing elements of matrix mult to 0.
	for(int i = 0; i < r1; i++){
		for(int j = 0; j < c2; j++)
		{
			result[i][j]=0;
		}
	}

	cerr << "3" << endl;

	// Multiplying matrix a and b and storing in array mult.
	for(int i = 0; i < r1; i++){
		for(int j = 0; j < c2; j++){
			for(int k = 0; k < c1; k++)
			{
				result[i][j] += a[i][k] * b[k][j];
			}
		}
	}
	return result;
}

std::vector<std::string> split(std::string str, char del) {
	int first = 0;
	int last = str.find_first_of(del);

	std::vector<std::string> result;

	while (first < str.size()) {
		std::string subStr(str, first, last - first);

		result.push_back(subStr);

		first = last + 1;
		last = str.find_first_of(del, first);

		if (last == std::string::npos) {
			last = str.size();
		}
	}

	return result;
}

class Card {
	int cardNumber;
	int instanceId;
	int location;
	int cardType;
	int cost;
	int attack;
	int defense;
	string abilities;
	int myHealthChange;
	int opponentHealthChange;
	int cardDraw;
	bool actionDone;
	int playScore;
	string command;
public:
	Card(int cardNumber, int instanceId, int location, int cardType, int cost, int attack, int defense, string abilities, int myHealthChange, int opponentHealthChange, int cardDraw, bool actionDone){
		this->cardNumber = cardNumber;
		this->instanceId = instanceId;
		this->location = location;
		this->cardType = cardType;
		this->cost = cost;
		this->attack = attack;
		this->defense = defense;
		this->abilities = abilities;
		this->myHealthChange = myHealthChange;
		this->opponentHealthChange = opponentHealthChange;
		this->cardDraw = cardDraw;
		this->actionDone = actionDone;
		this->playScore = 0;
	}

	Card* getCardCopy(){
		return new Card(this->cardNumber, this->instanceId, this->location, this->cardType, this->cost, this->attack, this->defense, this->abilities, this->myHealthChange, this->opponentHealthChange, this->cardDraw, this->actionDone);
	}

	int getDraw(){
		return cardDraw;
	}

	int getCost(){
		return cost;
	}

	int getID(){
		return instanceId;
	}

	int getAttack(){
		return attack;
	}

	int getDefense(){
		return defense;
	}

	string getAbilities(){
		return abilities;
	}

	bool isGuard(){
		return abilities.find("G") != std::string::npos;
	}

	bool isCharge(){
		return abilities.find("C") != std::string::npos;
	}

	bool isLethal(){
		return abilities.find("L") != std::string::npos;
	}

	bool isWard(){
		return abilities.find("W") != std::string::npos;
	}

	bool isDrain(){
		return abilities.find("D") != std::string::npos;
	}

	bool isBreakThrough(){
		return abilities.find("B") != std::string::npos;
	}

	bool getActionDone(){
		return actionDone;
	}

	void doAction(){
		this->actionDone = true;
	}

	int takeDamage(int damage){
		if(damage == 0){
			return 0;
		}
		if(isWard()){
			std::replace(abilities.begin(), abilities.end(), 'W', '-');
		}
		else{
			defense -= damage;
		}
	}

	// hyokati calculation
	int calcBasicValue(){
		if(defense <= 0){
			return 0;
		}
		int base = attack + defense;
		if(isWard()){
			base += attack;
		}
		if(isGuard()){
			base += 1;
		}
		if(isDrain()){
			//base += attack;
		}
		if(isBreakThrough()){
			if(attack >= 5){
				base += attack - 4;
			}
		}
		return base;
	}

	int getType(){
		return cardType;
	}

	bool operator<(const Card& another) const {
		return cost > another.cost;
	}

	void buff(Card* card){
		if(card->isGuard() && !isGuard()){
			abilities += 'G';
		}
		if(card->isLethal() && !isLethal()){
			abilities += 'L';
		}
		if(card->isWard() && !isWard()){
			abilities += 'W';
		}
		if(card->isDrain() && !isDrain()){
			abilities += 'D';
		}
		if(card->isBreakThrough() && !isBreakThrough()){
			abilities += 'B';
		}
		attack += card->getAttack();
		defense += card->getDefense();
	}

	void deBuff(Card* card){
		if(card->isGuard()){
			std::replace(abilities.begin(), abilities.end(), 'G', '-');
		}
		if(card->isLethal()){
			std::replace(abilities.begin(), abilities.end(), 'L', '-');
		}
		if(card->isWard()){
			std::replace(abilities.begin(), abilities.end(), 'W', '-');
		}
		if(card->isDrain()){
			std::replace(abilities.begin(), abilities.end(), 'D', '-');
		}
		if(card->isBreakThrough()){
			std::replace(abilities.begin(), abilities.end(), 'B', '-');
		}
		attack += card->getAttack();
		if(attack < 0){
			attack = 0;
		}
		takeDamage(-card->getDefense());
	}

	void setCommand(string command){
		this->command = command;
	}

	string getCommand(){
		return command;
	}

	int getCardNumber(){
		return cardNumber;
	}

	int getMyHealthChange(){
		return myHealthChange;
	}

	int getOpponentHealthChange(){
		return opponentHealthChange;
	}
};
bool cmp(Card *a, Card *b)
	{
		return (a->getCost() > b->getCost());
	}
class Player {
	int health;
	int mana;
	int deck;
	int rune;
public:
	Player(int health, int mana, int deck, int rune){
		this->health = health;
		this->mana = mana;
		this->deck = deck;
		this->rune = rune;
	}

	Player* getPlayerCopy(){
		return new Player (health, mana, deck, rune);
	}

	int getMana(){
		return mana;
	}

	int getDeck(){
		return deck;
	}

	int getHealth(){
		return health;
	}

	int takeDamage(int damage){
		health -= damage;
	}
};


int executeFight(Card* attacker, Card* target){
	attacker->doAction();
	if(attacker->isLethal() && attacker->getAttack() > 0){
		target->takeDamage(max(attacker->getAttack(), target->getDefense() + 1));
	}
	else{
		target->takeDamage(attacker->getAttack());
	}
	if(target->isLethal() && target->getAttack() > 0){
		attacker->takeDamage(max(target->getAttack(), attacker->getDefense() + 1));
	}
	else{
		attacker->takeDamage(target->getAttack());
	}
}


int getTradeScore(Card* me, Card* target){
	int initialScore = me->calcBasicValue() - target->calcBasicValue();
	Card* meCopy = me->getCardCopy();
	Card* targetCopy = target->getCardCopy();
	executeFight(meCopy, targetCopy);
	int afterScore = meCopy->calcBasicValue() - targetCopy->calcBasicValue();
	return afterScore - initialScore;
}

int LEATHAL_DANGER_VALUE = 7;
bool isSente = false;
int totalPick = 0;

class TradeScore
{
  public:
	int enemyIndex;
	int myIndex;
	double score;

	TradeScore(int enemyIndex, int myIndex, double score)
	{
		this->enemyIndex = enemyIndex;
		this->myIndex = myIndex;
		this->score = score;
	}
};

double getBoardScore(vector<Card*> myBoardCard, vector<Card*> enemyBoardCard, Player* me, Player* enemy){
	// enemy lethal
	int lethalScore = 0;
	bool hasTaunt = false;
	for(Card* enemyCard: enemyBoardCard){
		if(enemyCard->isGuard()){
			hasTaunt = true;
			break;
		}
	}
	int totalAttack = 0;
	int totalAttackHealth = 0;
	int nextTotalAttack = 0;
	int lifeStealTotal = 0;
	int enemyAttackTotal = 0;
	//cerr << "myboard" << endl;
	for(Card* card: myBoardCard){
		cerr << card->getID();
		nextTotalAttack += card->getAttack();
		totalAttackHealth += card->getDefense();
		if(!card->getActionDone()){
			totalAttack += card->getAttack();
		}
	}

	//cerr << endl << "enemyboard" << endl;
	for(Card* card: enemyBoardCard){
		cerr << card->getID();
		enemyAttackTotal += card->getAttack();
		if(card -> isDrain()){
			lifeStealTotal += card->getAttack();
		}
	}

	if(totalAttackHealth - enemyAttackTotal > 0){
		nextTotalAttack = nextTotalAttack * (totalAttackHealth - enemyAttackTotal) / totalAttackHealth;
	}
	else{
		nextTotalAttack = 0;
	}

	//cerr << endl;
	if((!hasTaunt && totalAttack >= enemy->getHealth()) || enemy->getHealth() <= 0){
		lethalScore = 10000;
	}
	else if(!hasTaunt && totalAttack + nextTotalAttack + LEATHAL_DANGER_VALUE >= enemy->getHealth() + lifeStealTotal){
		lethalScore = totalAttack + nextTotalAttack + LEATHAL_DANGER_VALUE - enemy->getHealth() - lifeStealTotal;
	}

	// next turn leathal score


	// min max algorizm
	// enemy card value is max(enemy card, max tradable my card)
	// my card value is max(my card, min tradable enemy card)
	int myCardValueTotal = 0;
	int myDefenceTotal = 0;
	for(Card* myCard: myBoardCard){
		int minTradeScore = 999;

		if(myCard->isGuard()){
			myDefenceTotal += myCard->getDefense();
		}
		int basicValue = myCard->calcBasicValue();
		if(minTradeScore != 999){
			myCardValueTotal += max(basicValue, minTradeScore + basicValue);
		}
		else{
			myCardValueTotal += basicValue;
		}
	}

	int enemyCardValueTotal = 0;
	enemyAttackTotal = 0;

	// donyoku trade search
	int* tradeValue = new int[enemyBoardCard.size()];
	bool *enemyTradeCompleted = new bool[myBoardCard.size()];
	for (int i = 0; i < enemyBoardCard.size(); i ++){
		tradeValue[i] = -999;
		enemyTradeCompleted[i] = false;
	}
	bool* myTradeCompleted = new bool[myBoardCard.size()];
	for (int i = 0; i < myBoardCard.size(); i ++){
		myTradeCompleted[i] = false;
	}
	vector<TradeScore*> trades;

	for (int i = 0; i < myBoardCard.size(); i++)
	{
		if (myDefenceTotal > 0 && !myBoardCard[i]->isGuard())
		{
			continue;
		}
		for (int n = 0; n < enemyBoardCard.size(); n++)
		{
			int score = getTradeScore(enemyBoardCard[n], myBoardCard[i]);
			if(score > 0){
				trades.push_back(new TradeScore(n, i, score));
			}
		}
	}

	sort(trades.begin(), trades.end(), [](const auto &lhs, const auto &rhs) {
		return lhs->score > rhs->score;
	});

	for(TradeScore* trade: trades){
		cerr << "trade:" << trade->score << endl;
		if (myTradeCompleted[trade->myIndex] == false && enemyTradeCompleted[trade->enemyIndex] == false){
			enemyCardValueTotal += trade->score;
			myTradeCompleted[trade->myIndex] = true;
			enemyTradeCompleted[trade->enemyIndex] = true;
		}
	}
	for (Card *enemyCard : enemyBoardCard){
		int basicValue = enemyCard->calcBasicValue();
		enemyAttackTotal += enemyCard->getAttack();
		enemyCardValueTotal += basicValue;
	}

		// avoid enemy leathal
	int leathalPenalty = 0;
	if(enemyAttackTotal >= me->getHealth() + myDefenceTotal - LEATHAL_DANGER_VALUE){
		leathalPenalty = (enemyAttackTotal - myDefenceTotal - me->getHealth() + LEATHAL_DANGER_VALUE + 1) * 100;
	}

	double finalScore = myCardValueTotal - enemyCardValueTotal - leathalPenalty + lethalScore;

	if(enemyBoardCard.size() == 0){
		finalScore += 0.5;
	}
	if(myBoardCard.size() == 0){
		finalScore -= 0.5;
	}

	return finalScore;
}

class SaikiResult{
public:
	vector<Card*> useCards;
	double score;

	SaikiResult(vector<Card*> useCards, double score){
		this->useCards = useCards;
		this->score = score;
	}
};

class Game {
	vector<Card*> myHandCard;
	vector<Card*> myBoardCard;
	vector<Card*> enemyBoardCard;
	Player* me;
	Player* opponent;
	std::stringstream ss;
	vector<Game*> nextGames;

	int manaLeft;
public:
	Game(vector<Card*> myHandCard, vector<Card*> myBoardCard, vector<Card*> enemyBoardCard, Player* me, Player* opponent, string ss, int manaLeft){
		this->myHandCard = myHandCard;
		this->myBoardCard = myBoardCard;
		this->enemyBoardCard = enemyBoardCard;
		this->me = me;
		this->opponent = opponent;
		this->ss << ss;
		this->manaLeft = manaLeft;
	}

	vector<Game*> getNextGames(){
		if(nextGames.size() > 0){
			return nextGames;
		}
		else{
			// 貪欲だが、1階層目だけ展開する

			double maxScore = -99999999;
			Game* resultGame = nullptr;
			double currentBoardScore = getBoardScore(myBoardCard, enemyBoardCard, me, opponent);

			for(Card* card: myBoardCard){
				// deal yuuri trade
				if(card->getAttack() == 0 || card->getActionDone()){
					continue;
				}
				Card* targetCard = nullptr;
				bool hasTaunt = false;
				// taunt
				for(Card* enemyCard: enemyBoardCard){
					if(enemyCard->isGuard()){
						hasTaunt = true;
						Game* simulateResult = simulateTrade(card, enemyCard);
						nextGames.push_back(simulateResult);
					}
				}
				if (!hasTaunt) {
					// calculate face attack value
					Game* simulateResult = simulateTrade(card, nullptr);
					nextGames.push_back(simulateResult);

					for(Card* enemyCard: enemyBoardCard){
						Game* simulateResult = simulateTrade(card, enemyCard);
						nextGames.push_back(simulateResult);
					}
				}
			}
		}
		return nextGames;
	}

	int originalSimulation(bool goToFace, Game** game){

		// 貪欲だが、1階層目だけ展開する

		double maxScore = -99999999;
		Game* resultGame = nullptr;

		for(Game* game: getNextGames()){
			vector<Game*> finalGames = game->getNextGames();
			for(Game* finalGame: finalGames){
				double score = finalGame->getGameBoardScore();
				if(score > maxScore){
					maxScore = score;
					resultGame = game;
				}
			}
		}

		// PASS
		if(resultGame == nullptr){
			resultGame = getCopy();
			resultGame->addString("PASS;");
		}
		*game = resultGame;
		return maxScore;
	}

	Game* simulation(bool goToFace){

		int maxScore = -99999999;
		Game* resultGame = nullptr;

		for(Card* card: myBoardCard){
			// deal yuuri trade
			if(card->getAttack() == 0 || card->getActionDone()){
				continue;
			}
			Card* targetCard = nullptr;
			bool hasTaunt = false;
			// taunt
			for(Card* enemyCard: enemyBoardCard){
				if(enemyCard->isGuard()){
					hasTaunt = true;
					Game* simulateResult = simulateTrade(card, enemyCard);
					double score = simulateResult->getGameBoardScore();
					if(score > maxScore){
						maxScore = score;
						resultGame = simulateResult;
						if(maxScore > 9000){
							return resultGame;
						}
					}
				}
			}
			if (!hasTaunt) {
				// calculate face attack value
				Game* simulateResult = simulateTrade(card, nullptr);
				double faceScore = simulateResult->getGameBoardScore();
				if(faceScore > maxScore){
					maxScore = faceScore;
					resultGame = simulateResult;
					if(maxScore > 9000){
						return resultGame;
					}
				}

				for(Card* enemyCard: enemyBoardCard){
					Game* simulateResult = simulateTrade(card, enemyCard);
					double score = simulateResult->getGameBoardScore();
					if(score > maxScore){
						maxScore = score;
						resultGame = simulateResult;
						if(maxScore > 9000){
							return resultGame;
						}
					}
				}
			}
		}

		// PASS
		if(resultGame == nullptr){
			resultGame = getCopy();
			resultGame->addString("PASS;");
		}

		return resultGame;
	}


Game* simulateTrade(Card* attacker, Card* target){
	vector<Card*> myBoardCardCopy;
	vector<Card*> enemyBoardCardCopy;
	Player* meCopy = me->getPlayerCopy();
	Player* enemyCopy = opponent->getPlayerCopy();
	std::stringstream ssCopy;
	ssCopy << ss.str(); // copy everything inside ss1's buffer to ss2's buffer
	// make copy board
	for(Card* card: myBoardCard){
		if(attacker->getID() == card->getID()){
			attacker = card->getCardCopy();
			myBoardCardCopy.push_back(attacker);
		}
		else{
			myBoardCardCopy.push_back(card);
		}
	}
	for(Card* card: enemyBoardCard){
		if(target != nullptr && target->getID() == card->getID()){
			target = card->getCardCopy();
			enemyBoardCardCopy.push_back(target);
		}
		else{
			enemyBoardCardCopy.push_back(card);
		}
	}
	if(target != nullptr){
		if(attacker->isDrain() && !target->isWard()){
			meCopy->takeDamage(-attacker->getAttack());
		}
		executeFight(attacker, target);
		// trunple
		if(attacker->isBreakThrough()){
			if(target->getDefense() < 0){
				enemyCopy->takeDamage(-target->getDefense());
			}
		}
	}
	// face
	else {
		if(attacker->isDrain()){
			meCopy->takeDamage(-attacker->getAttack());
		}
		attacker->doAction();
		enemyCopy->takeDamage(attacker->getAttack());
	}
	// jyoukyou kiin syori
	auto itr = myBoardCardCopy.begin();
	while (itr != myBoardCardCopy.end())
	{
		if ((*itr)->getDefense() <= 0)
		{
			itr = myBoardCardCopy.erase(itr);
		}
		else
		{
			itr++;
		}
	}

	itr = enemyBoardCardCopy.begin();
	while (itr != enemyBoardCardCopy.end())
	{
		if ((*itr)->getDefense() <= 0)
		{
			itr = enemyBoardCardCopy.erase(itr);
		}
		else
		{
			itr++;
		}
	}
	if(target != nullptr){
		ssCopy << "ATTACK " << attacker->getID() << " " << target->getID() << ";";
	}
	else{
		ssCopy << "ATTACK " << attacker->getID() << " " << -1 << ";";
	}
	return new Game(myHandCard, myBoardCardCopy, enemyBoardCardCopy, meCopy, enemyCopy, ssCopy.str(), manaLeft);
}


	Game* getCopy(){
		vector<Card*> myHandCardCopy;
		vector<Card*> myBoardCardCopy;
		vector<Card*> enemyBoardCardCopy;
		Player* meCopy;
		Player* opponentCopy;
		std::stringstream ssCopy;
		ssCopy << ss.str(); // copy everything inside ss1's buffer to ss2's buffer

		// make copy board
		for(Card* card: myHandCard){
			myHandCardCopy.push_back(card->getCardCopy());
		}
		for(Card* card: myBoardCard){
			myBoardCardCopy.push_back(card->getCardCopy());
		}
		for(Card* card: enemyBoardCard){
			enemyBoardCardCopy.push_back(card->getCardCopy());
		}
		meCopy = me->getPlayerCopy();
		opponentCopy = opponent->getPlayerCopy();
		return new Game(myHandCardCopy, myBoardCardCopy, enemyBoardCardCopy, meCopy, opponentCopy, ssCopy.str(), manaLeft);
	}

	double saikiUpperTime = 50;
	std::chrono::system_clock::time_point saikiTime; // 型は auto で可


	SaikiResult* saikiPlayCard(int index, vector<Card*> currentPlay, int leftMana, int boardLeft, Game* current){
		SaikiResult* result = new SaikiResult(currentPlay, 0);
		vector<Card*> playCard;

		double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(saikiTime-start).count(); //処理に要した時間をミリ秒に変換
		cerr << "time:" << elapsed << endl;
		if(elapsed > saikiUpperTime){
			result->score = -99999999;
			return result;
		}
		if(myHandCard.size() <= index){
			saikiTime = std::chrono::system_clock::now();  // 計測終了時間
			Game* copyGame = current->getCopy();
			int score = 0;
			int totalDraw = 0;
			for(Card* card: currentPlay){
				totalDraw += card->getDraw();
				// use health only cards
				if(card->getType() == 3 && card->getDefense() == 0){
					totalDraw += 2;
				}
			}
			// simulate trade
			while(copyGame->getCommands().find("PASS") == std::string::npos){
				copyGame = copyGame->simulation(false);
			}
			result->score = copyGame->getGameBoardScore() - currentPlay.size() + totalDraw;
			return result;
		}
		result = saikiPlayCard(index + 1, currentPlay, leftMana, boardLeft, current);
		if(boardLeft == 0 && myHandCard[index]->getType() == 0){
			return result;
		}

		if(myHandCard[index]->getCost() <= leftMana){
			if(myHandCard[index]->getType() == 0){
				boardLeft --;
			}
			vector<Card*> newPlay;
			SaikiResult* tmpResult;
			int tmpScore = 0;
			for(Card* card: currentPlay){
				newPlay.push_back(card);
			}
			Card* playCardCopy = myHandCard[index]->getCardCopy();
			newPlay.push_back(playCardCopy);
			if(playCardCopy->getType() == 0){
				boardLeft --;
			}

			Game* newBoard = current->getCopy();
			newBoard->setBestCardPlay(playCardCopy, newBoard->getGameBoardScore());
			newBoard->playCard(playCardCopy);

			tmpResult = saikiPlayCard(index + 1, newPlay, leftMana - myHandCard[index]->getCost(), boardLeft, newBoard);
			if(tmpResult->score > result->score){
				result = tmpResult;
			}
		}

		return result;
	}

	double getGameBoardScore(){
		return getBoardScore(myBoardCard, enemyBoardCard, me, opponent);
	}

	vector<Card*> calcBestPlayCards(bool goToFace){
		vector<Card*> firstCards;
		return saikiPlayCard(0, firstCards, manaLeft, 6 - myBoardCard.size(), this)->useCards;
	}

	void setBestCardPlay(Card* hand, int currentBoardScore){
		// health change
		Player* copyMe = me->getPlayerCopy();
		Player* copyOpponent = opponent->getPlayerCopy();
		copyMe->takeDamage(-hand->getMyHealthChange());
		copyOpponent->takeDamage(-hand->getOpponentHealthChange());

		if(hand->getType() == 1){
			if(myBoardCard.size() != 0){
				double maxScore = -99999;
				for(Card* targetCreature : myBoardCard){
					vector<Card*> myBoardCardCopy;
					for(Card* card: myBoardCard){
						if(targetCreature->getID() == card->getID()){
							Card* buffedCard = card->getCardCopy();
							buffedCard->buff(hand);
							myBoardCardCopy.push_back(buffedCard);
						}
						else{
							myBoardCardCopy.push_back(card);
						}
					}
					Game* current = new Game(myHandCard, myBoardCardCopy, enemyBoardCard, copyMe, copyOpponent, "", manaLeft);
					while(current->getCommands().find("PASS") == std::string::npos){
						current = current->simulation(false);
					}
					double score = current->getGameBoardScore() - currentBoardScore - 1 + hand->getDraw();
					if(score > maxScore){
						maxScore = score;
						std::stringstream ss;
						ss << "USE " << hand->getID() << " " << targetCreature->getID() << ";";
						hand->setCommand(ss.str());
					}
				}
			}
			else{

			}
		}
		else if(hand->getType() == 2){
			if(enemyBoardCard.size() != 0){
				double maxScore = -99999;
				for(Card* targetCreature : enemyBoardCard){
					vector<Card*> enemyBoardCardCopy;
					for(Card* card: enemyBoardCard){
						if(targetCreature->getID() == card->getID()){
							Card* buffedCard = card->getCardCopy();
							buffedCard->deBuff(hand);
							enemyBoardCardCopy.push_back(buffedCard);
							// jyoukyou kiin syori
							auto itr = enemyBoardCardCopy.begin();
							itr = enemyBoardCardCopy.begin();
							while (itr != enemyBoardCardCopy.end())
							{
								if ((*itr)->getDefense() <= 0)
								{
									itr = enemyBoardCardCopy.erase(itr);
								}
								else
								{
									itr++;
								}
							}
						}
						else{
							enemyBoardCardCopy.push_back(card);
						}
					}
					Game* current = new Game(myHandCard, myBoardCard, enemyBoardCardCopy, copyMe, copyOpponent, "", manaLeft);
					while(current->getCommands().find("PASS") == std::string::npos){
						current = current->simulation(false);
					}
					double score = current->getGameBoardScore() - currentBoardScore - 1 + hand->getDraw();
					if(score > maxScore){
						maxScore = score;
						std::stringstream ss;
						ss << "USE " << hand->getID() << " " << targetCreature->getID() << ";";
						hand->setCommand(ss.str());
					}
				}
			}
			else{

			}
		}
		else if(hand->getType() == 3){
			if(hand->getDefense() < 0){
				double maxScore = -99999;
				// target player score
				Player* damagedOpponent = copyOpponent->getPlayerCopy();
				damagedOpponent->takeDamage(-hand->getDefense());
				Game* current = new Game(myHandCard, myBoardCard, enemyBoardCard, copyMe, damagedOpponent, "", manaLeft);
				while(current->getCommands().find("PASS") == std::string::npos){
					current = current->simulation(false);
				}
				maxScore = current->getGameBoardScore() - currentBoardScore - 1 + hand->getDraw();
				std::stringstream ss;
				ss << "USE " << hand->getID() << " " << "-1" << ";";
				hand->setCommand(ss.str());

				for(Card* targetCreature : enemyBoardCard){
					vector<Card*> enemyBoardCardCopy;
					for(Card* card: enemyBoardCard){
						if(targetCreature->getID() == card->getID()){
							Card* buffedCard = card->getCardCopy();
							buffedCard->deBuff(hand);
							enemyBoardCardCopy.push_back(buffedCard);
							// jyoukyou kiin syori
							auto itr = enemyBoardCardCopy.begin();
							itr = enemyBoardCardCopy.begin();
							while (itr != enemyBoardCardCopy.end())
							{
								if ((*itr)->getDefense() <= 0)
								{
									itr = enemyBoardCardCopy.erase(itr);
								}
								else
								{
									itr++;
								}
							}
						}
						else{
							enemyBoardCardCopy.push_back(card);
						}
					}
					Game* current = new Game(myHandCard, myBoardCard, enemyBoardCardCopy, copyMe, copyOpponent, "", manaLeft);
					while(current->getCommands().find("PASS") == std::string::npos){
						current = current->simulation(false);
					}
					double score = current->getGameBoardScore() - currentBoardScore - 1 + hand->getDraw();
					if(score > maxScore){
						maxScore = score;
						std::stringstream ss;
						ss << "USE " << hand->getID() << " " << targetCreature->getID() << ";";
						hand->setCommand(ss.str());
					}
				}
			}
			else{
				int score = getBoardScore(myBoardCard, enemyBoardCard, copyMe, copyOpponent) - currentBoardScore + 1 + hand->getDraw();
				std::stringstream ss;
				ss << "USE " << hand->getID() << " -1" << ";";
				hand->setCommand(ss.str());
			}
		}
		else if(hand->getType() == 0){
			if(hand->isCharge() && myBoardCard.size() < 6){
				vector<Card*> myBoardCardCopy;
				for(Card* card: myBoardCard){
					myBoardCardCopy.push_back(card);
				}
				myBoardCardCopy.push_back(hand);

				Game* current = new Game(myHandCard, myBoardCardCopy, enemyBoardCard, copyMe, copyOpponent, "", manaLeft);
				while(current->getCommands().find("PASS") == std::string::npos){
					current = current->simulation(false);
				}
				double score = current->getGameBoardScore() - currentBoardScore - 1 + hand->getDraw();
				std::stringstream ss;
				ss << "SUMMON " << hand->getID() << ";";
				hand->setCommand(ss.str());
			}
			else if(myBoardCard.size() < 6){
				vector<Card*> myBoardCardCopy;
				for(Card* card: myBoardCard){
					myBoardCardCopy.push_back(card);
				}
				myBoardCardCopy.push_back(hand);
				std::stringstream ss;
				ss << "SUMMON " << hand->getID() << ";";
				hand->setCommand(ss.str());
			}
			else{

			}
		}
#ifdef DEBUG_PRINT
		cerr << hand->getID() << "playValueBefore=" << hand->getPlayScore() << endl;
#endif
	}

	void playCard(Card* card){
		// remove from hand
		auto itr = myHandCard.begin();
		while (itr != myHandCard.end())
		{
			if ((*itr)->getID() == card->getID())
			{
				itr = myHandCard.erase(itr);
				break;
			}
			else
			{
				itr++;
			}
		}

		// health change
		me->takeDamage(-card->getMyHealthChange());
		opponent->takeDamage(-card->getOpponentHealthChange());

		if(card->getType() == 0 && myBoardCard.size() < 6){
			ss << "SUMMON " << card->getID() << ";";
			addMyCardToBoard(card);
			// charge
			if(!card->isCharge()){
				card->doAction();
			}
			manaLeft -= card->getCost();
		}
		else if(card->getType() == 1 && card->getCommand() != ""){
			ss << card->getCommand();
			int targetID = std::atoi(split(card->getCommand(), ' ')[2].c_str());
			for(Card* target: myBoardCard){
				if(targetID == target->getID()){
					target->buff(card);
					break;
				}
			}
			manaLeft -= card->getCost();
		}
		else if(card->getType() == 2 && card->getCommand() != ""){
			ss << card->getCommand();
			int targetID = std::atoi(split(card->getCommand(), ' ')[2].c_str());
			for(Card* target: enemyBoardCard){
				if(targetID == target->getID()){
					target->deBuff(card);
					// jyoukyou kiin syori
					auto itr = enemyBoardCard.begin();
					itr = enemyBoardCard.begin();
					while (itr != enemyBoardCard.end())
					{
						if ((*itr)->getDefense() <= 0)
						{
							itr = enemyBoardCard.erase(itr);
						}
						else
						{
							itr++;
						}
					}
					break;
				}
			}
			manaLeft -= card->getCost();
		}
		else if(card->getType() == 3 && card->getCommand() != ""){
			ss << card->getCommand();
			int targetID = std::atoi(split(card->getCommand(), ' ')[2].c_str());
			if(targetID != -1){
				for(Card* target: enemyBoardCard){
					if(targetID == target->getID()){
						target->deBuff(card);
						// jyoukyou kiin syori
						auto itr = enemyBoardCard.begin();
						itr = enemyBoardCard.begin();
						while (itr != enemyBoardCard.end())
						{
							if ((*itr)->getDefense() <= 0)
							{
								itr = enemyBoardCard.erase(itr);
							}
							else
							{
								itr++;
							}
						}
						break;
					}
				}
			}
			manaLeft -= card->getCost();
		}
	}

	string getCommands(){
		return ss.str();
	}

	void addMyCardToBoard(Card* card){
		myBoardCard.push_back(card);
	}

	void addString(string str){
	   ss << str;
	}
};

// mana curve
int* manaCurve = new int[13];
int idealManaCurve[13] = {2, 6, 4, 6, 3, 3, 2, 2, 1, 1, 1, 1, 1};

// by statistics
int senteIdealManaCurve[13] = {0, 0, 2, 6, 5, 5, 6, 4, 4, 2, 0, 0, 2};
int goteIdealManaCurve[13] = {5, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

// card cost counts
int catdCostCounts[13] = {7,12,33,28,30,18,15,7,5,3,0,0,2};

int* currentDeck = new int[160];
int pickedCard = 0;
int HIDDEN_SIZE = 100;
vector<vector<vector<double> > > w;
vector<vector<double> > b;

vector<vector<double> > relu(vector<vector<double> > input){
	int r = input.size();
	int c = input[0].size();
	for(int i = 0; i < r; i ++){
		for(int n = 0; n < c; n ++){
			if(input[i][n] < 0){
				input[i][n] = 0;
			}
		}
	}
	return input;
}

vector<vector<double> > sigmoid(vector<vector<double> > input){
	int r = input.size();
	int c = input[0].size();
	for(int i = 0; i < r; i ++){
		for(int n = 0; n < c; n ++){
			input[i][n] = 1/(1 + exp(-input[i][n]));
		}
	}
	return input;
}

vector<vector<double> > tanh(vector<vector<double> > input){
	int r = input.size();
	int c = input[0].size();
	for(int i = 0; i < r; i ++){
		for(int n = 0; n < c; n ++){
			input[i][n] = (1 - exp(-2 * input[i][n])) / (1 + exp(-2 * input[i][n]));
		}
	}
	return input;
}

string activation;

vector<vector<double> > applyActivation(vector<vector<double> > input){
	cerr << activation << endl;
	if(activation == "\"relu\""){
		return relu(input);
	}
	if(activation == "\"tanh\""){
		return tanh(input);
	}
	if(activation == "\"sigmoid\""){
		return sigmoid(input);
	}
	//exit(1);
}

vector<vector<double> > getOneHot(){

	vector<vector<double> > result;
	result.resize(1);
	result[0].resize(643);
	for(int i = 0; i < 160; i++){
		if(currentDeck[i] == 0){
			result[0][i * 4] = 1;
		}
		if(currentDeck[i] == 1){
			result[0][i * 4 + 1] = 1;
		}
		if(currentDeck[i] == 2){
			result[0][i * 4 + 2] = 1;
		}
		if(currentDeck[i] >= 3){
			result[0][i * 4 + 3] = 1;
		}
	}
	if(isSente){
		result[0][640] = 1;
		result[0][641] = 0;
	}
	else{
		result[0][640] = 1;
		result[0][641] = 0;
	}
	result[0][642] = totalPick;
	return result;
}

vector<vector<double> > calcNN(){
	vector<vector<double> > inputVector = getOneHot();

	// calc matrix 1
	cerr << "layer1" << endl;
	vector<vector<double> > x1 = mulMatrix(inputVector, w[0]);
	cerr << "endmul" << endl;
	for(int i = 0; i < HIDDEN_SIZE; i ++){
		x1[0][i] += b[0][i];
	}
	//applyActivation(x1);
	x1 = relu(x1);
	// calc matrix 2
	cerr << "layer2" << endl;
	vector<vector<double> > x2 = mulMatrix(x1, w[1]);
	for(int i = 0; i < HIDDEN_SIZE; i ++){
		x2[0][i] += b[1][i];
	}
	//applyActivation(x2);
	x2 = relu(x2);
	// calc matrix 3
	cerr << "layer3" << endl;
	vector<vector<double> > x3 = mulMatrix(x2, w[2]);
	for(int i = 0; i < 160; i ++){
		x3[0][i] += b[2][i];
	}
	x3 = tanh(x3);
	//applyActivation(x3);
	return x3;
}

string modelDir;
string logFileName;
string logDirName;
string confDir;
int hidden_size = 0;

#ifdef READ_EPOCH_FILE
void readModel(){
	std::string str;

	// read activation
	std::ifstream ifs(confDir);
	if (ifs.fail()){
		std::cerr << "失敗" << std::endl;
		return;
	}
	while (getline(ifs, str)){
		str.erase(remove(str.begin(), str.end(),' '), str.end());
		if(str.substr(0, 10) == "activation"){
			activation = str.substr(11);
		}
		if(str.substr(0, 10) == "activation"){
			activation = str.substr(11);
		}
	}

	// load bias
	for(int n = 0; n < 3; n ++){
		cerr << "read bias file" << n << endl;
		string fileName;
		int size;
		if(n == 0){
			fileName = modelDir + "/Inference-Forward1-biases.csv";
		} else if(n == 1){
			fileName = modelDir + "/Inference-Forward2-biases.csv";
		} else if(n == 2){
			fileName = modelDir + "/Inference-Output-biases.csv";
		}
		std::ifstream ifs(fileName);
		if (ifs.fail()){
			std::cerr << "失敗" << std::endl;
			return;
		}
		//b[n] = new double[size];
		vector<double> oneLine;
		while (getline(ifs, str)){
			oneLine.push_back(std::atof(str.c_str()));
		}
		b.push_back(oneLine);
	}

	// load weight
	for(int n = 0; n < 3; n ++){
		cerr << "read weight file" << n << endl;
		string fileName;
		int size1, size2;
		if(n == 0){
			fileName = modelDir  + "/Inference-Forward1-weights.csv";
		} else if(n == 1){
			fileName = modelDir  + "/Inference-Forward2-weights.csv";
		} else if(n == 2){
			fileName = modelDir  + "/Inference-Output-weights.csv";
		}
		std::ifstream ifs(fileName);
		if (ifs.fail()){
			std::cerr << "失敗" << std::endl;
			return;
		}
		vector< vector <double> > weight;
		while (getline(ifs, str)){
			vector<string> result = split(str, ' ');
			vector<double> oneLine;
			for(int j = 0; j < result.size(); j ++){
				oneLine.push_back(std::atof(result[j].c_str()));
			}
			weight.push_back(oneLine);
		}
		w.push_back(weight);
	}
	cerr << "read weight done" << endl;
}
#endif

int main(int argc,char *argv[])
{

#ifdef DEBUG
	cerr << "debug mode" << endl;
#endif
#ifdef RANDOM_PICK
	cerr << "random mode" << endl;
#endif
#ifdef READ_EPOCH_FILE
	cerr << "epoch mode" << endl;
#endif
#ifdef TEKAGEN
	cerr << "tekagen mode" << endl;
#endif
#ifdef DEBUG_PRINT
	cerr << "debug print mode" << endl;
#endif


#ifdef DEBUG
	logDirName = argv[1];
#endif

#ifdef READ_EPOCH_FILE
	modelDir = argv[2];
	confDir = argv[3];
	readModel();
	for(int i = 0; i < 160; i ++){
		currentDeck[i] = 1;
	}
	vector<vector<double> > nn = calcNN();
	for(int i = 0; i < 160; i ++){
		cerr << nn[0][i] << endl;
	}
#endif

	for(int i = 0; i < 160; i ++){
		currentDeck[i] = 0;
	}
	for(int i = 0; i < 13; i ++){
		manaCurve[i] = 0;
	}

	double** weight = new double*[160];
	for(int i = 0; i < 160; i ++){
		weight[i] = new double[160];
	}

	int strCnt = 0;
	for(int i = 0; i < 160; i ++){
        for(int j = i; j < 160; j ++){
			string target = weightString.substr(strCnt * 4, 4);
			weight[i][j] = (double)std::atoi(target.c_str()) / 1000;
			weight[j][i] = (double)std::atoi(target.c_str()) / 1000;
			strCnt ++;
		}
	}

	// game loop
	while (1) {
		vector<Card*> myHandCard;
		vector<Card*> myBoardCard;
		vector<Card*> enemyBoardCard;
		Player* me;
		Player* opponent;
		for (int i = 0; i < 2; i++) {
			int playerHealth;
			int playerMana;
			int playerDeck;
			int playerRune;
			cin >> playerHealth >> playerMana >> playerDeck >> playerRune; cin.ignore();
			cerr << playerHealth << " " << playerMana << " " << playerDeck << " " << playerRune << endl;
			if(i == 0){
				me = new Player(playerHealth, playerMana, playerDeck, playerRune);
			}
			else {
				opponent = new Player(playerHealth, playerMana, playerDeck, playerRune);
			}
		}
		int opponentHand;
		cin >> opponentHand; cin.ignore();
		int cardCount;
		cin >> cardCount; cin.ignore();
		for (int i = 0; i < cardCount; i++) {
			int cardNumber;
			int instanceId;
			int location;
			int cardType;
			int cost;
			int attack;
			int defense;
			string abilities;
			int myHealthChange;
			int opponentHealthChange;
			int cardDraw;
			cin >> cardNumber >> instanceId >> location >> cardType >> cost >> attack >> defense >> abilities >> myHealthChange >> opponentHealthChange >> cardDraw; cin.ignore();
			cerr << cardNumber << " " << instanceId << " " << location << " " << cardType << " " << cost << " " << attack << " " << defense << " " << abilities << " " << myHealthChange << " " << opponentHealthChange << " " << cardDraw << endl;
			Card* card = new Card(cardNumber, instanceId, location, cardType, cost, attack, defense, abilities, myHealthChange, opponentHealthChange, cardDraw, false);
			if(location == 0){
				myHandCard.push_back(card);
			}
			else if (location == 1){
				myBoardCard.push_back(card);
			}
			else if(location == -1){
				enemyBoardCard.push_back(card);
			}
		}

		start = std::chrono::system_clock::now(); // 計測開始時間

		// while draft phase
		Card* lowestCard = nullptr;

		if(me->getDeck() == opponent->getDeck()){
			isSente = true;
		}
		else{
			isSente = false;
		}

		int lowestIndex = -1;
		double maxScore = -9999999;
		int i = 0;
		double expectedManaCurve[13] = {0,0,0,0,0,0,0,0,0,0,0,0,0};
		for(int n = 0; n < 13; n ++){
			expectedManaCurve[n] = manaCurve[n] + (30 - pickedCard - 1) * ((double)catdCostCounts[n] / 160);
#ifdef DEBUG_PRINT
			cerr << "mana" << n << ":" << manaCurve[n] << endl;
			cerr << "expedtedmana" << n << ":" << expectedManaCurve[n] << endl;
#endif
		}


		// think about mana curve
		if(me->getMana() == 0){
			for(Card* card: myHandCard){
				//double score = idealManaCurve[card->getCost()] - expectedManaCurve[card->getCost()];
				double score = 0;
				for(int i = 0; i < 160; i ++){
					if(i == card->getCardNumber() - 1){
						score += weight[card->getCardNumber() - 1][i];
					}
					else {
						score += weight[card->getCardNumber() - 1][i] * currentDeck[card->getCardNumber() - 1];
					}
				}
#ifndef TEKAGEN

				//score += cardValues[card->getCardNumber() - 1] * 200;
#endif
#ifdef READ_EPOCH_FILE
				//score = calcNN()[0][card->getCardNumber() - 1];
#endif
				/*if(card->getType() != 0){
					score = -9999;
				}*/
				cerr << maxScore << endl;
				if(lowestCard == nullptr || maxScore < score){
					lowestCard = card;
					lowestIndex = i;
					maxScore = score;
				}
				i ++;
			}
#ifdef RANDOM_PICK
			std::random_device rd;
			std::mt19937 mt(rd());
			std::uniform_int_distribution<int> dice(0,10);
			int rnd = dice(mt);
			if(rnd <= 2){
				lowestIndex = rnd;
				lowestCard = myHandCard[lowestIndex];
			}
#endif

			cerr << lowestIndex << endl;
			cout << "PICK " << lowestIndex << endl;
			totalPick ++;

#ifdef DEBUG
			ofstream outputfile(logDirName, ios::app);
			for(int i = 0; i < 160; i++){
				outputfile << currentDeck[i] << " ";
			}
			outputfile << endl;
			for(Card* card: myHandCard){
				outputfile << card->getCardNumber() - 1 << " ";
			}
			outputfile << endl;
			outputfile << lowestCard->getCardNumber() - 1 << endl;
			outputfile.close();
#endif DEBUG

			currentDeck[lowestCard->getCardNumber() - 1]++;
			manaCurve[lowestCard->getCost()]++;
			pickedCard ++;
		}
		else{
			// judge leathal
			bool goToFace = false;
			int totalAttack = 0;
			int totalDefence = 0;
			for(Card* card: myBoardCard){
				totalAttack += card->getAttack();
			}
			for(Card* card: enemyBoardCard){
				totalDefence += card->getDefense();
			}
			if(totalAttack * 2 > opponent->getHealth() + totalDefence){
				goToFace = true;
			}

			// battle phase
			cerr << goToFace << endl;
			Game* current = new Game(myHandCard, myBoardCard, enemyBoardCard, me, opponent, "", me->getMana());

			// make play card score
			vector<Card*> beforePlayCards = current->calcBestPlayCards(goToFace);
			for(Card* card: beforePlayCards){
				cerr << "beforePlay:" << card->getCommand() << endl;
				current->playCard(card);
			}


			vector<Game*> history;
			vector<int> scoreHistory;
			history.push_back(current);
			scoreHistory.push_back(current->getGameBoardScore());
			while(current->getCommands().find("PASS") == std::string::npos){
				Game* next;
				int score = current->originalSimulation(goToFace, &next);
				history.push_back(next);
				scoreHistory.push_back(score);
				current = next;
				//cerr << current->getCommands() << endl;
			}

			int passIndex = current->getCommands().find("PASS");

			vector<Card*> playCards;

			// play cards untill no more want to play
			playCards = current->calcBestPlayCards(false);
			while(playCards.size() > 0){
				for(Card* card: playCards){
					current -> playCard(card);
				}
				playCards = current->calcBestPlayCards(false);
			}

			// use chage cards
			current = current->simulation(goToFace);
			while(current->getCommands().find("PASS", passIndex + 1) == std::string::npos){
				current = current->simulation(goToFace);
				cerr << current->getCommands() << endl;
			}

			std::chrono::system_clock::time_point  end; // 型は auto で可
			end = std::chrono::system_clock::now();  // 計測終了時間
			double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end-start).count(); //処理に要した時間をミリ秒に変換

			cout << current->getCommands() << "PASS " << elapsed << "ms;" << endl;
		}

	}
}
