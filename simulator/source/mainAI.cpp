#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>
#include <random>
#include <fstream>
#include <chrono>


//#include "mainAI.hpp"

//8/4 use card value
// 80 to 15! so strong

#ifdef READ_EPOCH_FILE
#include <dirent.h>
#include <cctype>
#include <algorithm>
#include <sys/stat.h>
#include <sys/types.h>
#endif

#ifdef DEBUG
#include<iostream>
#include<fstream>
#endif

std::chrono::system_clock::time_point  start; // 型は auto で可

double cardValues[160] = {0.000433529,-0.0037734,0.0028331,-0.00276243,0.00866409,0.00926344,0.029362,0.00190389,0.00771829,-0.0085139,0.00581557,-0.00253273,0.00805238,-0.0130036,0.00763868,-0.00624154,0.0089192,0.0130663,0.00519659,-0.00748882,0.00147536,-0.00139611,0.00551419,-0.00618836,0.00153689,0.000873843,0.00477187,0.000716053,0.00987119,-0.000576243,-0.00940427,0.00990177,0.00820396,-0.00255504,-0.0107639,0.000583625,0.0121412,-0.00073514,-0.00222392,-0.00431018,-0.00395841,-0.0183421,-0.00577225,0.0173889,-0.00909391,-0.00408303,0,0.00701637,0.0153841,0.00628554,0.0268336,0.00478309,0.0175815,0.00212425,-0.0197821,-0.00298329,-0.0164201,-0.0026735,-0.000324628,-0.00508684,0.00347833,-0.00198799,-0.00943521,0.00879462,0.0269608,0.0134584,0.0148968,0.0268221,0.0128387,-0.00183205,-0.0080639,0.00564646,0.0012535,-0.00336064,0.00918993,-0.0122763,0.000566452,-0.00734073,0.00065331,0.014409,0.00213692,0.00267892,-0.00134645,0.00707656,0.00295596,-0.0021922,0,0.00973341,-0.00481232,-0.00470274,0.00171294,-0.00863851,-3.54887e-05,-0.00495691,0.0114015,0.00413277,0.00348691,-0.00129351,0.00659267,-0.000100164,-0.0088968,-0.0131982,0.0147266,0.00447027,0.00678091,0.00324469,-0.0110531,-0.00837989,0.00685987,-0.029233,0.00775385,-0.00119425,-0.0179728,0.00456286,0.00147749,0.0126015,-0.00583768,-0.000873908,0.00163193,-0.00624224,0.00362457,0.00108682,-0.00808074,-0.0122458,-0.00222169,0.00195875,-0.00252306,0.00807992,0.00380313,-0.00646744,-0.00850858,-0.00819513,0.0121858,-0.00390422,0.00307388,-0.00422738,-0.00375989,-0.0140479,0.013371,-0.033683,0.0047868,-0.00601638,-0.0131875,0.00265587,0.00170743,-0.00901371,0.00466675,-0.000131648,-0.00772928,0.00934158,0.0150233,0.00444484,-0.0306787,-0.0165606,0.000195894,-0.0167981,0.00228041,0.00319721,-0.0113772,-0.0294801};

double senteCardValues[160] = {0.00522914,0.00649074,0.0373472,-0.0227351,-0.00615287,0.0583284,0.117264,0.00518128,-0.0229118,0.0199622,0.016954,0.0367072,-3.47338e-05,-0.0239185,0.0342298,0.00916495,0.0333294,0.0585944,-0.015473,-0.0210462,0.00870821,0.00380487,0.00702071,-0.00884353,0.0367473,0.0364663,0.0318212,0.0166431,0.0555974,0.00806699,-0.0242122,0.0638749,0.0276655,0.0257424,0.00435631,0.0218679,0.0536554,-0.0172122,-0.0176253,-0.00827046,0.0125336,-0.0425849,-0.00745449,-0.0444275,0.00801553,0.0149138,0.0152714,0.112694,0.0736462,0.0546047,0.087719,0.0399407,0.0484114,0.00566218,-0.0620186,-0.0223839,-0.030543,-0.000530424,0.0104515,-0.024526,0.0891363,-0.0177142,-0.0282858,-0.0109838,0.10237,0.0549253,0.0388632,0.106084,0.0579393,0.00547221,0.0160756,-0.00560487,-0.000281269,-0.00367716,0.0479686,-0.043348,0.0239022,0.0156017,0.0342234,0.0675693,-0.00216348,0.0144876,-0.0211105,0.0384108,0.050097,-0.0108636,0.0130793,0.0367385,0.0203271,0.0244206,0.0256851,-0.0378035,-0.0102143,-0.00291633,-0.0127916,0.0152501,0.011471,-0.0159928,0.0275439,-0.0158701,-0.00819335,0.00643682,-0.00720459,0.0150764,0.066655,0.0771835,-0.0403507,-0.00771895,0.0473175,-0.0580764,0.0544935,-0.00267719,-0.049929,-0.0176468,0.0591496,-0.0151179,-0.0818333,0.0477531,-0.0583297,-0.0321885,0.0361966,-0.0132881,-0.0260448,-0.0562397,0.00154604,-0.0317302,0.00139487,0.0555814,0.0239356,-0.0355977,-0.0438997,-0.0354203,0.0333321,-0.000637868,0.040769,-0.0166353,0.0168322,-0.0338096,0.00584953,-0.0601254,-0.0140267,0.000416507,-0.0195359,0.0231085,0.040729,-0.0332866,0.0730047,0.0234788,-0.000336922,0.0467499,0.0917952,-0.0114921,-0.0741875,-0.00545544,0.0344129,-0.0618768,-0.0208459,0.0276144,-0.0317566,-0.0677456};
double goteCardValues[160] = {0.058102,0.0258042,0.0706185,0.0099431,0.00904855,0.0591329,0.125346,0.0218466,0.020942,-0.015102,0.0741874,0.0464433,0.017383,-0.0199364,0.00431621,-0.00986173,0.00546549,0.024209,-0.00782556,-0.00957748,-0.000463608,0.0294612,-0.0142696,-0.0256717,0.020775,0.0584086,0.0350105,0.0120206,0.0363414,-0.00952028,-0.0109271,0.0728354,0.0129478,0.000485747,-0.0118241,0.00750278,0.0286469,0.0280213,-0.0508536,-0.0117841,-0.00596415,-0.038574,-0.0171501,0.0307178,-0.0267872,0.00771515,-0.00802544,0.128753,0.0791327,-0.0027949,0.0935145,0.0037073,0.0538065,0.0727279,-0.0338961,-0.0136646,-0.030621,-0.0168686,0.0344697,-0.0184215,0.0332275,-0.0177833,-0.0147347,0.0239804,0.0790134,-0.0220797,0.0484203,0.120965,-0.0389621,-0.0041262,0.0185518,-0.0233834,0.00837519,0.0151833,-0.0103635,-0.0222291,0.0225975,-0.0163072,0.00631932,0.034658,0.0248979,0.0338133,-0.0118245,0.00102474,0.0759433,0.0152856,0.0123044,0.0578618,0.00247702,-0.00230104,0.0011328,-0.0305029,-0.0111287,0.00527088,0.0401635,0.0109352,-0.00980729,0.00650463,0.0486083,0.0311611,-0.0171294,-0.023658,0.0058718,0.0126698,0.0167936,0.046664,-0.00408254,-0.0160383,-0.0010001,-0.0574716,0.0641651,0.00498499,-0.0181988,0.0598401,0.0132905,0.0472286,0.01458,-0.0185259,0.0953192,-0.0105867,-0.00523497,-0.00779782,-0.0409266,-0.0401784,0.0130724,0.00367043,0.0282207,0.0195838,-0.000376817,-0.00276598,-0.019775,-0.0356905,-0.014633,-0.0264432,0.0233628,0.0137823,-0.00883867,-0.0322892,-0.0208647,-0.0524126,0.102244,-0.00579516,-0.00289143,0.0483592,0.0424053,-0.0255751,0.0560565,0.0456625,-0.0542025,0.0401625,0.0659664,0.0241994,-0.045094,-0.0450714,0.0499352,-0.0355589,0.0385908,0.0301813,-0.0194965,-0.0706499};

double senteCardWinrate[160][31]={{0.690717,0.681791,0.679938,0.665513,0.679775,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688243,0.690559,0.691038,0.714754,0.621212,0.8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689485,0.686554,0.687448,0.682013,0.619048,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.68961,0.679302,0.673139,0.56962,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690066,0.685084,0.672657,0.662404,0.556818,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689313,0.685912,0.684192,0.695652,0.663551,0.75,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687713,0.690979,0.689315,0.700948,0.717172,0.652778,0.8125,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689194,0.691167,0.659779,0.701245,0.54,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687108,0.689883,0.702328,0.714866,0.707407,0.767857,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690175,0.67692,0.659634,0.615385,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687949,0.690838,0.692348,0.703448,0.66323,0.758621,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688846,0.686091,0.700899,0.655296,0.818182,0.75,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687275,0.693765,0.704962,0.705448,0.652174,0.833333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689403,0.680426,0.646699,0.623188,0.636364,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.68707,0.694867,0.704871,0.70962,0.736842,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.6891,0.685073,0.673049,0.728395,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687466,0.691915,0.701716,0.713323,0.674074,0.769231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.686152,0.695743,0.700347,0.721632,0.710059,0.75,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.686174,0.6973,0.706814,0.704908,0.723757,0.555556,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689474,0.68313,0.671334,0.686275,0.611111,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.686953,0.696537,0.698937,0.717949,0.666667,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688576,0.688492,0.693667,0.732648,0.636364,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.684817,0.696418,0.706392,0.71432,0.770764,0.641509,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689194,0.68555,0.685236,0.695279,0.71875,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688472,0.691501,0.688539,0.670635,0.722222,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689551,0.681828,0.686018,0.679389,0.623529,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689484,0.684607,0.675486,0.648415,0.575,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688705,0.68754,0.702778,0.685567,0.642857,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.684888,0.706299,0.711562,0.739387,0.804878,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687893,0.691227,0.700933,0.709877,0.661972,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689512,0.681323,0.676529,0.675676,0.714286,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.682486,0.701744,0.719479,0.734962,0.748126,0.743243,0.625,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.685568,0.701308,0.708378,0.72686,0.692308,0.75,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688338,0.691012,0.691312,0.710317,0.740741,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689421,0.681567,0.667152,0.640625,0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.686893,0.697623,0.703537,0.730769,0.657143,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.682772,0.704187,0.717371,0.741414,0.716102,0.65625,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.691476,0.679576,0.673755,0.650075,0.611111,0.625,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689329,0.689104,0.676357,0.65932,0.755814,0.8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689408,0.685073,0.675985,0.676301,0.52381,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689768,0.684873,0.663263,0.646259,0.705882,0.666667,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690188,0.663687,0.632231,0.730769,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.69028,0.676676,0.662681,0.617284,0.428571,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687221,0.691982,0.696446,0.695699,0.701734,0.635514,0.75,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689347,0.682062,0.678176,0.64557,0.6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690364,0.682572,0.660796,0.634146,0.571429,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.6909,0.671208,0.659681,0.570312,0.555556,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.692058,0.680032,0.67808,0.661758,0.685294,0.692308,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690112,0.687214,0.677843,0.662827,0.643192,0.8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687337,0.691944,0.695492,0.702554,0.726161,0.733333,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.683991,0.694214,0.711792,0.722118,0.743177,0.725118,0.65,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687716,0.694305,0.692063,0.716642,0.69863,0.625,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.691261,0.684946,0.677569,0.659565,0.654896,0.710526,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688125,0.692118,0.690007,0.681611,0.755245,0.7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690592,0.65652,0.607477,0.578947,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689162,0.686603,0.660328,0.695122,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690478,0.661692,0.606999,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.68894,0.687704,0.68609,0.65343,0.625,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.686632,0.695014,0.700941,0.705046,0.719212,0.75,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688104,0.694864,0.681632,0.66855,0.757895,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.685388,0.698067,0.707431,0.712526,0.697842,0.714286,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689277,0.689703,0.674583,0.649606,0.583333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690024,0.669619,0.6538,0.7,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689826,0.68819,0.666384,0.674169,0.686275,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.6887,0.688452,0.685132,0.699438,0.703622,0.707965,0.875,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.684138,0.696919,0.711798,0.720752,0.724886,0.652174,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.68137,0.704039,0.719641,0.728868,0.75436,0.774194,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.68206,0.697627,0.716288,0.725601,0.74818,0.706485,0.702703,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.684177,0.694318,0.712946,0.735845,0.741676,0.742857,0.285714,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688595,0.68968,0.690195,0.711957,0.571429,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689075,0.685734,0.671672,0.587302,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687899,0.693736,0.694924,0.700162,0.677966,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689344,0.684088,0.684832,0.636364,0.8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688487,0.691138,0.686894,0.688,0.645161,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.685249,0.699025,0.707257,0.718479,0.707237,0.84375,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690092,0.67368,0.642249,0.655172,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.686063,0.697265,0.701434,0.707875,0.724638,0.583333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688881,0.688499,0.672549,0.64,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688018,0.69337,0.686747,0.676471,0.684211,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.684027,0.698949,0.709995,0.712301,0.718876,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.686054,0.698213,0.702152,0.698925,0.666667,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687102,0.694656,0.696351,0.685357,0.669975,0.772727,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690796,0.677711,0.670391,0.617822,0.684211,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690382,0.68774,0.653309,0.645283,0.539474,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687535,0.692623,0.700421,0.68058,0.705202,0.857143,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689286,0.687523,0.67433,0.676923,0.608696,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688474,0.6966,0.664294,0.649932,0.742857,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.686362,0.695731,0.700289,0.710464,0.64467,0.766667,0.75,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689435,0.68559,0.676409,0.614504,0.555556,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.68931,0.683955,0.68401,0.614035,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.69138,0.676883,0.668558,0.643204,0.54902,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690953,0.674218,0.664732,0.587549,0.666667,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689661,0.684443,0.683529,0.692909,0.69375,0.75,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689297,0.685557,0.660348,0.641949,0.666667,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688973,0.689172,0.680609,0.697161,0.72973,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689725,0.686482,0.669167,0.654762,0.649485,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688048,0.689476,0.698225,0.691213,0.688995,0.75,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688413,0.690702,0.690282,0.676712,0.638889,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687221,0.693188,0.697923,0.692767,0.679359,0.730769,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688002,0.691902,0.697364,0.687952,0.7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689319,0.681234,0.664273,0.675926,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.6893,0.68173,0.652856,0.714286,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687566,0.69116,0.695357,0.697452,0.734748,0.625,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688056,0.692094,0.6961,0.700368,0.75,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687392,0.691958,0.698876,0.703213,0.702811,0.692308,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688123,0.693767,0.685949,0.684385,0.61165,0.888889,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690426,0.67225,0.625523,0.574468,0.571429,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689982,0.678309,0.663547,0.642276,0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.686399,0.695084,0.700632,0.724989,0.746154,0.75,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.691077,0.652704,0.587432,0.517857,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688193,0.688991,0.695716,0.699945,0.698113,0.636364,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.68894,0.689441,0.679554,0.645503,0.631579,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690732,0.659939,0.634902,0.392857,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.687315,0.693726,0.691416,0.698766,0.689394,0.72973,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689373,0.687001,0.679317,0.653465,0.65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.68644,0.692219,0.696077,0.710912,0.703196,0.671642,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689072,0.686822,0.68777,0.661765,0.578947,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.691677,0.673521,0.655182,0.648718,0.604938,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689824,0.685527,0.68322,0.674822,0.687179,0.636364,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690094,0.670681,0.627193,0.589744,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688244,0.694021,0.683333,0.594595,0.875,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.6896,0.682625,0.667145,0.641379,0.625,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689819,0.670662,0.667915,0.555556,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.692084,0.650336,0.61631,0.617647,0.333333,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689426,0.68518,0.681854,0.666667,0.7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.69023,0.683355,0.679298,0.666144,0.695122,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689715,0.684098,0.672623,0.682143,0.589744,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689422,0.6851,0.688312,0.675854,0.723404,0.8,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688781,0.690155,0.683399,0.662544,0.8,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.69008,0.6735,0.643239,0.7,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689508,0.676266,0.695652,0.588235,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689877,0.680195,0.656844,0.655367,0.714286,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689786,0.683294,0.689125,0.690837,0.67,0.607143,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688244,0.693155,0.699725,0.714286,0.6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688974,0.686187,0.691843,0.684899,0.73494,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690106,0.677034,0.669688,0.690608,0.625,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689276,0.680458,0.690613,0.693182,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690051,0.671383,0.617613,0.512195,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.692383,0.677875,0.672362,0.654728,0.696629,0.592593,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.692053,0.634194,0.573107,0.5,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.692774,0.674287,0.665372,0.615789,0.438596,0.333333,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690173,0.678658,0.637059,0.672131,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690709,0.66199,0.628571,0.537313,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.691694,0.68087,0.670753,0.677664,0.652482,0.809524,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690011,0.684244,0.680019,0.668502,0.62069,0.777778,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689292,0.680381,0.70116,0.661017,0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689371,0.684664,0.682213,0.685714,0.666667,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.691172,0.668776,0.662802,0.640693,0.611111,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688604,0.691373,0.67989,0.661616,0.75,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.691564,0.676589,0.671173,0.633966,0.55,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690347,0.68621,0.680876,0.673852,0.687879,0.685039,0.625,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.686597,0.696456,0.698865,0.688717,0.664804,0.690476,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.691543,0.635698,0.58589,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689693,0.674333,0.64196,0.583333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690166,0.682016,0.679747,0.673839,0.771084,0.666667,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.691465,0.652416,0.612418,0.5,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688668,0.689853,0.685332,0.694404,0.652778,0.75,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.690702,0.68279,0.675325,0.662338,0.65,0.9375,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.689811,0.673216,0.659341,0.636364,0.25,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.691403,0.638133,0.566246,0.6,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
};

double goteCardWinrate[160][31]={{0.308262,0.321403,0.327057,0.328939,0.410714,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311389,0.310685,0.313625,0.282024,0.34,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.308525,0.320087,0.317299,0.344694,0.39886,0.428571,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.31106,0.31338,0.32013,0.266667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.308777,0.319566,0.341226,0.350708,0.31746,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.309723,0.318682,0.319213,0.324037,0.373016,0.6,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.308418,0.310029,0.330878,0.341513,0.346378,0.39375,0.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.309887,0.315457,0.351953,0.333333,0.27027,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312173,0.310257,0.304348,0.2978,0.297753,0.328767,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312175,0.303253,0.29202,0.347826,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311105,0.312932,0.308688,0.31272,0.305921,0.351351,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311212,0.313991,0.301178,0.290036,0.257143,0.6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312694,0.30689,0.293207,0.292776,0.326316,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312319,0.294884,0.29036,0.287879,0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312315,0.30771,0.297875,0.311399,0.270833,0.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311946,0.304786,0.289993,0.16,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311923,0.310123,0.299244,0.310423,0.377778,0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311678,0.310969,0.307719,0.303983,0.299419,0.225806,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313,0.305936,0.298674,0.295413,0.274286,0.357143,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312029,0.305012,0.29975,0.294686,0.111111,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.31243,0.307001,0.303614,0.282464,0.239437,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312425,0.307524,0.287486,0.241784,0.0666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.314283,0.30734,0.294488,0.287897,0.242472,0.321429,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312336,0.305611,0.300611,0.278656,0.193548,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311402,0.311648,0.303326,0.227848,0.348837,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.309734,0.323938,0.317498,0.370079,0.326316,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310442,0.317822,0.316578,0.295597,0.444444,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310406,0.319811,0.30559,0.297767,0.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312608,0.304459,0.308658,0.264634,0.196429,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311646,0.310762,0.305365,0.283154,0.344828,0.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312475,0.300743,0.287864,0.246479,0.166667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.315416,0.303773,0.290071,0.274875,0.267164,0.219178,0.125,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313435,0.305853,0.28713,0.263158,0.292857,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312559,0.305623,0.286959,0.283224,0.21875,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312453,0.298613,0.276198,0.257143,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313295,0.305492,0.275455,0.237113,0.166667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.316149,0.297012,0.290189,0.278363,0.262931,0.230769,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.308168,0.322932,0.330231,0.31203,0.28972,0.75,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310612,0.311221,0.32321,0.338208,0.326923,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.31194,0.307102,0.301661,0.288952,0.304348,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311593,0.303904,0.331688,0.329327,0.241379,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312557,0.289612,0.250689,0.294118,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312064,0.306518,0.287552,0.232394,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311789,0.309271,0.309859,0.304386,0.335183,0.383838,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313471,0.289268,0.250651,0.236842,0.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311781,0.308983,0.306988,0.262537,0.125,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.30896,0.332606,0.321626,0.28972,0.3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.304342,0.320307,0.349257,0.370362,0.39049,0.367089,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.306206,0.32015,0.345279,0.391854,0.457627,0.352941,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.31122,0.310879,0.31086,0.324289,0.272021,0.355556,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313759,0.305569,0.299604,0.304661,0.296106,0.284314,0.357143,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311246,0.310452,0.315682,0.296183,0.405797,0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.305357,0.318432,0.343019,0.373786,0.365385,0.443038,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311255,0.311562,0.313556,0.293117,0.283465,0.3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.31261,0.287814,0.258597,0.142857,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311785,0.306951,0.296237,0.262411,0.444444,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312615,0.289037,0.269076,0.0666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312654,0.299806,0.304456,0.303249,0.6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313819,0.306589,0.290963,0.278504,0.234973,0.125,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.314176,0.298775,0.289767,0.305927,0.25,0.111111,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.314589,0.305079,0.288828,0.256013,0.228188,0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311951,0.309292,0.301319,0.320463,0.292683,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.31085,0.319867,0.28401,0.222222,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.308327,0.32006,0.345238,0.347107,0.361702,0.6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.307656,0.316351,0.327126,0.342739,0.32816,0.40708,0.2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.314137,0.305207,0.298499,0.292447,0.3,0.295082,0.142857,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.315626,0.301018,0.296677,0.284673,0.268556,0.183333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.314087,0.305702,0.303678,0.291538,0.299764,0.252525,0.365854,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313512,0.305427,0.307789,0.277158,0.297136,0.313433,0.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.31163,0.308097,0.305279,0.305085,0.333333,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311918,0.302233,0.307368,0.295082,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313029,0.299578,0.305127,0.275081,0.341463,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311389,0.311327,0.302847,0.301471,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312511,0.303484,0.296482,0.284507,0.45,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.314954,0.299959,0.294071,0.272931,0.286119,0.257143,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312266,0.300536,0.274086,0.272727,0.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.314562,0.302633,0.292363,0.280687,0.252788,0.125,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312604,0.298547,0.278815,0.215385,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312229,0.309202,0.288334,0.271642,0.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313579,0.306374,0.298715,0.308895,0.292994,0.137931,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313694,0.303488,0.298908,0.290245,0.273504,0.3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312429,0.305824,0.308325,0.313651,0.331765,0.315789,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.308451,0.32673,0.335603,0.379439,0.380952,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.307496,0.32388,0.363384,0.342391,0.462687,0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311462,0.310713,0.305761,0.333524,0.278351,0.230769,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311267,0.314912,0.292295,0.295222,0.310345,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310928,0.30657,0.348798,0.365819,0.307692,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313079,0.304837,0.30704,0.287742,0.313158,0.375,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310668,0.315318,0.319883,0.295082,0.222222,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311058,0.313365,0.310329,0.32,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.307835,0.32567,0.347018,0.318078,0.258065,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312293,0.307055,0.277983,0.325926,0.285714,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.31014,0.31398,0.319409,0.347694,0.267176,0.142857,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311065,0.312211,0.317394,0.354545,0.222222,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.309449,0.314911,0.336934,0.340061,0.3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.309204,0.318188,0.342762,0.372268,0.409091,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311422,0.311083,0.313181,0.284185,0.32973,0.1875,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311224,0.312022,0.308189,0.307172,0.396825,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310983,0.311288,0.312362,0.317409,0.359091,0.27027,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312224,0.306525,0.303709,0.299883,0.337349,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311514,0.306696,0.318018,0.292929,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312551,0.293765,0.260465,0.162162,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310666,0.314488,0.309887,0.314174,0.312808,0.368421,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311985,0.305963,0.313018,0.28853,0.242424,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312046,0.309718,0.304348,0.301959,0.309013,0.375,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311417,0.310463,0.313223,0.291171,0.33,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312116,0.301622,0.295785,0.234568,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311812,0.308354,0.285781,0.282443,0.25,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312715,0.310536,0.294317,0.287008,0.271739,0.142857,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312995,0.282112,0.28065,0.22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311435,0.315565,0.299701,0.283565,0.278409,0.125,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311561,0.308617,0.315246,0.276276,0.357143,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311998,0.302202,0.266833,0.166667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312544,0.308394,0.305863,0.299946,0.303263,0.244444,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.309819,0.317501,0.323434,0.342857,0.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310952,0.314772,0.310531,0.306285,0.291111,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313421,0.2987,0.290296,0.291417,0.275862,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.307317,0.33381,0.33696,0.356322,0.471429,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.309831,0.31837,0.312386,0.319244,0.247368,0.222222,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311317,0.311559,0.296692,0.27907,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311247,0.311531,0.311172,0.297753,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310444,0.316882,0.336742,0.298507,0.380952,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312208,0.295715,0.284173,0.328767,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311603,0.309573,0.279833,0.299145,0.375,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.3111,0.313435,0.306159,0.307155,0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.308818,0.32065,0.327969,0.328918,0.246154,0.384615,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311566,0.310509,0.303233,0.308219,0.216216,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.309498,0.322458,0.308318,0.300513,0.310345,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310127,0.317553,0.322531,0.304673,0.206897,0.166667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310838,0.319302,0.289332,0.256757,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311976,0.304074,0.254545,0.338028,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313213,0.292522,0.293976,0.301775,0.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.308527,0.320726,0.321142,0.3188,0.287097,0.241379,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312174,0.304578,0.27812,0.227642,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310498,0.315108,0.318284,0.296566,0.270588,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310479,0.318713,0.316022,0.290909,0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311012,0.31724,0.281167,0.337079,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311958,0.3018,0.277188,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.304941,0.328725,0.343354,0.369006,0.296928,0.424242,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313404,0.278329,0.208763,0.181818,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.305584,0.332707,0.341958,0.411899,0.421875,0.375,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310069,0.323642,0.305022,0.3125,0.32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312576,0.29408,0.258465,0.302326,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.306547,0.324613,0.330796,0.362406,0.314079,0.36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.309371,0.317704,0.32556,0.344093,0.306452,0.285714,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.31112,0.316314,0.27909,0.23622,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.309587,0.322091,0.328097,0.312757,0.347826,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.307946,0.338569,0.345526,0.375,0.47619,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.3123,0.30199,0.29881,0.320856,0.4,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.306906,0.329837,0.343959,0.368421,0.380952,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.306489,0.316024,0.335995,0.353514,0.384,0.409836,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.31307,0.303948,0.307142,0.304582,0.310092,0.208333,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312918,0.279458,0.263238,0.0952381,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.31253,0.291701,0.262679,0.135135,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.309068,0.322626,0.322751,0.293915,0.41573,0.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313014,0.285066,0.295097,0.25,0.333333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311219,0.31276,0.311816,0.279687,0.30303,0.111111,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.307953,0.318632,0.340366,0.361983,0.337209,0.47619,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.310968,0.31593,0.318627,0.263158,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.313184,0.27193,0.260097,0.444444,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
};

double senteManaCurve[13][31]={{0.705282,0.690961,0.673143,0.659786,0.603434,0.564498,0.554688,0.546875,0.526316,0.75,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.710093,0.701052,0.698189,0.690746,0.682523,0.667274,0.622719,0.605574,0.561947,0.5625,0.473684,0.333333,0.5,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.69964,0.704587,0.705906,0.703048,0.69614,0.690192,0.677743,0.669386,0.662299,0.639722,0.605093,0.625833,0.61474,0.599388,0.586572,0.521008,0.566038,0.473684,0.428571,0,0,0,0,0,0,0,0,0,0,0,0},
{0.587361,0.634654,0.648441,0.670875,0.68381,0.693484,0.694875,0.694397,0.68747,0.679654,0.649194,0.652174,0.684211,0.577778,0.555556,0.705882,1,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.635607,0.662964,0.671926,0.684339,0.691221,0.695304,0.692944,0.685996,0.681838,0.664344,0.679775,0.695055,0.612717,0.653846,0.576923,0.727273,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.642323,0.671566,0.674957,0.689113,0.695767,0.696091,0.694627,0.69069,0.67332,0.685811,0.642857,0.777778,0.8,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.634163,0.66449,0.682499,0.695186,0.701548,0.706682,0.714874,0.707211,0.710526,0.540541,0.428571,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.664386,0.680357,0.691852,0.701367,0.702396,0.702425,0.688291,0.64135,0.823529,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.683505,0.689101,0.696049,0.700252,0.702316,0.631336,0.540984,0.75,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.68302,0.693832,0.696776,0.693681,0.707519,0.698276,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688731,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.688731,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.686002,0.694031,0.690465,0.692533,0.701283,0.671795,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};

double goteManaCurve[13][31]={{0.292966,0.310785,0.328464,0.345464,0.36502,0.400424,0.381526,0.416667,0.666667,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.287077,0.288741,0.299712,0.309538,0.324827,0.343009,0.362403,0.364726,0.402655,0.446154,0.571429,0.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.258824,0.263147,0.277921,0.293118,0.304579,0.317792,0.328168,0.337976,0.350169,0.369244,0.37108,0.359079,0.377163,0.393496,0.387302,0.435115,0.4,0.434783,0.25,0,0,0,0,0,0,0,0,0,0,0,0},
{0.365854,0.341153,0.335605,0.317682,0.316411,0.310879,0.309968,0.307653,0.303581,0.307327,0.314866,0.314685,0.311688,0.273585,0.244444,0.428571,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.319658,0.319275,0.312769,0.315088,0.31125,0.308912,0.310414,0.306712,0.313075,0.328125,0.320088,0.320856,0.367232,0.215686,0.421053,0.125,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.347017,0.334202,0.323989,0.31179,0.307403,0.305796,0.300712,0.289158,0.278431,0.305031,0.197368,0.333333,0.666667,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.350826,0.335666,0.322231,0.310925,0.298943,0.286747,0.267838,0.272415,0.208835,0.305556,0.0909091,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.333206,0.322706,0.312861,0.299821,0.288833,0.290509,0.293121,0.252525,0.130435,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.314674,0.3108,0.309405,0.300856,0.300303,0.229508,0.340426,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.318105,0.31003,0.298553,0.283034,0.263615,0.243243,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311268,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.311268,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0.312141,0.311556,0.306321,0.312297,0.309925,0.254335,0.117647,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};

//TODO think about card advantage
//TODO 

// 0805 honkide 13th

using namespace std;

vector<vector<double> > mulMatrix(vector<vector<double> > a,vector<vector<double> > b)
{
    int r1 = a.size();
    int c1 = a[0].size();
    int r2 = b.size();
    int c2 = b[0].size();

    cerr << c1 << ":" << r1 << ":" << c2 << ":" << r2 << endl;

    // If column of first matrix in not equal to row of second matrix,
    // ask the user to enter the size of matrix again.
    while (c1!=r2)
    {
        cerr << "Error! column of first matrix not equal to row of second.";
        cin >> c1;
    }

    cerr << "1" << endl;

    vector<vector<double> > result;
    result.resize(r1);
    for(int i = 0; i < r1; i++){
        result[i].resize(c2);
    }

    cerr << "2" << endl;

    // Initializing elements of matrix mult to 0.
    for(int i = 0; i < r1; i++){
        for(int j = 0; j < c2; j++)
        {
            result[i][j]=0;
        }
    }

    cerr << "3" << endl;

    // Multiplying matrix a and b and storing in array mult.
    for(int i = 0; i < r1; i++){
        for(int j = 0; j < c2; j++){
            for(int k = 0; k < c1; k++)
            {
                //cerr << i << ":" << j << ":" << k << endl;
                /*cerr << result[j][i] << endl;
                cerr << a[k][i] << endl;
                cerr << b[j][k] << endl;*/
                result[i][j] += a[i][k] * b[k][j];
            }
        }
    }

    // Displaying the multiplication of two matrix.
    //cerr << "Output Matrix: " << endl;
    /*for(int i = 0; i < r1; i++)
    for(int j = 0; j < c2; j++)
    {
        //cerr << " " << result[i][j];
        if(j == c2-1)
            //cerr << endl;
    }*/
    return result;
}

std::vector<std::string> split(std::string str, char del) {
    int first = 0;
    int last = str.find_first_of(del);
 
    std::vector<std::string> result;
 
    while (first < str.size()) {
        std::string subStr(str, first, last - first);
 
        result.push_back(subStr);
 
        first = last + 1;
        last = str.find_first_of(del, first);
 
        if (last == std::string::npos) {
            last = str.size();
        }
    }
 
    return result;
}

class Card {
    int cardNumber;
    int instanceId;
    int location;
    int cardType;
    int cost;
    int attack;
    int defense;
    string abilities;
    int myHealthChange;
    int opponentHealthChange;
    int cardDraw;
    bool actionDone;
    int playScore;
    string command;
public:
    Card(int cardNumber, int instanceId, int location, int cardType, int cost, int attack, int defense, string abilities, int myHealthChange, int opponentHealthChange, int cardDraw, bool actionDone){
        this->cardNumber = cardNumber;
        this->instanceId = instanceId;
        this->location = location;
        this->cardType = cardType;
        this->cost = cost;
        this->attack = attack;
        this->defense = defense;
        this->abilities = abilities;
        this->myHealthChange = myHealthChange;
        this->opponentHealthChange = opponentHealthChange;
        this->cardDraw = cardDraw;
        this->actionDone = actionDone;
        this->playScore = 0;
    }

    Card* getCardCopy(){
        return new Card(this->cardNumber, this->instanceId, this->location, this->cardType, this->cost, this->attack, this->defense, this->abilities, this->myHealthChange, this->opponentHealthChange, this->cardDraw, this->actionDone);
    }

    int getDraw(){
        return cardDraw;
    }

    int getCost(){
        return cost;
    }

    int getID(){
        return instanceId;
    }

    int getAttack(){
        return attack;
    }

    int getDefense(){
        return defense;
    }

    string getAbilities(){
        return abilities;
    }

    bool isGuard(){
        return abilities.find("G") != std::string::npos;
    }

    bool isCharge(){
        return abilities.find("C") != std::string::npos;
    }

    bool isLethal(){
        return abilities.find("L") != std::string::npos;
    }

    bool isWard(){
        return abilities.find("W") != std::string::npos;
    }

    bool isDrain(){
        return abilities.find("D") != std::string::npos;
    }

    bool isBreakThrough(){
        return abilities.find("B") != std::string::npos;
    }

    bool getActionDone(){
        return actionDone;
    }

    void doAction(){
        this->actionDone = true;
    }

    int takeDamage(int damage){
        if(damage == 0){
            return 0;
        }
        if(isWard()){
            std::replace(abilities.begin(), abilities.end(), 'W', '-');
        }
        else{
            defense -= damage;
        }
    }

    // hyokati calculation
    int calcBasicValue(){
        if(defense <= 0){
            return 0;
        }
        int base = attack + defense;
        if(isWard()){
            base += attack;
        }
        if(isGuard()){
            base += 1;
        }
        if(isDrain()){
            //base += attack;
        }
        if(isBreakThrough()){
            if(attack >= 5){
                base += attack - 4;
            }
        }
        return base;
    }

    int getType(){
        return cardType;
    }

    bool operator<(const Card& another) const {
        return cost > another.cost;
    }

    int getPlayScore(){
        return playScore;
    }

    void setPlayScore(int score){
        this->playScore = score;
    }

    void buff(Card* card){
        if(card->isGuard() && !isGuard()){
            abilities += 'G';
        }
        if(card->isLethal() && !isLethal()){
            abilities += 'L';
        }
        if(card->isWard() && !isWard()){
            abilities += 'W';
        }
        if(card->isDrain() && !isDrain()){
            abilities += 'D';
        }
        if(card->isBreakThrough() && !isBreakThrough()){
            abilities += 'B';
        }
        attack += card->getAttack();
        defense += card->getDefense();
    }

    void deBuff(Card* card){
        if(card->isGuard()){
            std::replace(abilities.begin(), abilities.end(), 'G', '-');
        }
        if(card->isLethal()){
            std::replace(abilities.begin(), abilities.end(), 'L', '-');
        }
        if(card->isWard()){
            std::replace(abilities.begin(), abilities.end(), 'W', '-');
        }
        if(card->isDrain()){
            std::replace(abilities.begin(), abilities.end(), 'D', '-');
        }
        if(card->isBreakThrough()){
            std::replace(abilities.begin(), abilities.end(), 'B', '-');
        }
        attack += card->getAttack();
        if(attack < 0){
            attack = 0;
        }
        takeDamage(-card->getDefense());
    }

    void setCommand(string command){
        this->command = command;
    }

    string getCommand(){
        return command;
    }

    int getCardNumber(){
        return cardNumber;
    }

    int getMyHealthChange(){
        return myHealthChange;
    }

    int getOpponentHealthChange(){
        return opponentHealthChange;
    }
};
bool cmp(Card *a, Card *b)
    {
        return (a->getCost() > b->getCost()); 
    } 
class Player {
    int health;
    int mana;
    int deck;
    int rune;
public:
    Player(int health, int mana, int deck, int rune){
        this->health = health;
        this->mana = mana;
        this->deck = deck;
        this->rune = rune;
    }

    Player* getPlayerCopy(){
        return new Player (health, mana, deck, rune);
    }

    int getMana(){
        return mana;
    }

    int getDeck(){
        return deck;
    }

    int getHealth(){
        return health;
    }

    int takeDamage(int damage){
        health -= damage;
    }
};


int executeFight(Card* attacker, Card* target){
    attacker->doAction();
    if(attacker->isLethal()){
        target->takeDamage(max(attacker->getAttack(), target->getDefense() + 1));
    }
    else{
        target->takeDamage(attacker->getAttack());
    }
    if(target->isLethal()){
        attacker->takeDamage(max(target->getAttack(), attacker->getDefense() + 1));
    }
    else{
        attacker->takeDamage(target->getAttack());
    }
}


int getTradeScore(Card* me, Card* target){
    int initialScore = me->calcBasicValue() - target->calcBasicValue();
    Card* meCopy = me->getCardCopy();
    Card* targetCopy = target->getCardCopy();
    executeFight(meCopy, targetCopy);
    int afterScore = meCopy->calcBasicValue() - targetCopy->calcBasicValue();
    return afterScore - initialScore;
    /*int dealDamage = min(me->getAttack(), target->getDefense());
    if( target->isWard()){
        dealDamage = 1 + target->getAttack();
    }
    int takeDamage = min(target->getAttack(), me->getDefense());
    if( me->isWard()){
        takeDamage = 1;
    }
    int score = dealDamage - takeDamage;
    if(me->getAttack() >= target->getDefense() || (me->isLethal() && dealDamage > 0)){
        score += target->getDefense() + target->getAttack();
    }
    if(target->getAttack() >= me->getDefense() || (target->isLethal() && takeDamage > 0)){
        score -= me->getDefense() + me->getAttack();
    }
    return score;*/
}

int LEATHAL_DANGER_VALUE = 7;
bool isSente = false;
int totalPick = 0;

double getBoardScore(vector<Card*> myBoardCard, vector<Card*> enemyBoardCard, Player* me, Player* enemy){
    // enemy lethal
    int lethalScore = 0;
    bool hasTaunt = false;
    for(Card* enemyCard: enemyBoardCard){
        if(enemyCard->isGuard()){
            hasTaunt = true;
            break;
        }
    }
    int totalAttack = 0;
    int totalAttackHealth = 0;
    int nextTotalAttack = 0;
    int lifeStealTotal = 0;
    int enemyAttackTotal = 0;
    //cerr << "myboard" << endl;
    for(Card* card: myBoardCard){
        cerr << card->getID();
        nextTotalAttack += card->getAttack();
        totalAttackHealth += card->getDefense();
        if(!card->getActionDone()){
            totalAttack += card->getAttack();
        }
    }

    //cerr << endl << "enemyboard" << endl;
    for(Card* card: enemyBoardCard){
        cerr << card->getID();
        enemyAttackTotal += card->getAttack();
        if(card -> isDrain()){
            lifeStealTotal += card->getAttack();
        }
    }

    if(totalAttackHealth - enemyAttackTotal > 0){
        nextTotalAttack = nextTotalAttack * (totalAttackHealth - enemyAttackTotal) / totalAttackHealth;
    }
    else{
        nextTotalAttack = 0;
    }

    //cerr << endl;
    if((!hasTaunt && totalAttack >= enemy->getHealth()) || enemy->getHealth() <= 0){
        lethalScore = 10000;
    }
    else if(!hasTaunt && totalAttack + nextTotalAttack + LEATHAL_DANGER_VALUE >= enemy->getHealth() + lifeStealTotal){
        lethalScore = totalAttack + nextTotalAttack + LEATHAL_DANGER_VALUE - enemy->getHealth() - lifeStealTotal;
    }

    // next turn leathal score


    // min max algorizm
    // enemy card value is max(enemy card, max tradable my card)
    // my card value is max(my card, min tradable enemy card)
    int myCardValueTotal = 0;
    int myDefenceTotal = 0;
    for(Card* myCard: myBoardCard){
        int minTradeScore = -999;
        for(Card* enemyCard: enemyBoardCard){
            int score = getTradeScore(myCard, enemyCard);
            if(minTradeScore > score){
                minTradeScore = score;
            }
        }
        if(myCard->isGuard()){
            myDefenceTotal += myCard->getDefense();
        }
        int basicValue = myCard->calcBasicValue();
        /*if(myCard->isLethal()){
            basicValue += me->getMana();
        }*/
        if(minTradeScore != -999){
            myCardValueTotal += max(basicValue, minTradeScore + basicValue);
        }
        else{
            myCardValueTotal += basicValue;
        }
    }

    int enemyCardValueTotal = 0;
    enemyAttackTotal = 0;
    for(Card* enemyCard: enemyBoardCard){
        int maxTradeScore = 0;
        for(Card* myCard: myBoardCard){
            int score = getTradeScore(enemyCard, myCard);
            if(maxTradeScore < score){
                maxTradeScore = score;
            }
        }
        int basicValue = enemyCard->calcBasicValue();
        /*if(enemyCard->isLethal()){
            basicValue += me->getMana();
        }*/
        enemyAttackTotal += enemyCard->getAttack();
        enemyCardValueTotal += max(basicValue, maxTradeScore + basicValue);
    }
    // avoid enemy leathal
    int leathalPenalty = 0;
    if(enemyAttackTotal >= me->getHealth() + myDefenceTotal - LEATHAL_DANGER_VALUE){
        leathalPenalty = (enemyAttackTotal - myDefenceTotal - me->getHealth() + LEATHAL_DANGER_VALUE + 1) * 100;
    }

    double finalScore = myCardValueTotal - enemyCardValueTotal - leathalPenalty + lethalScore;
    //cerr << finalScore << endl;

    //finalScore += me->getHealth() / 1000;
    //finalScore -= enemy->getHealth() / 1000;

    if(enemyBoardCard.size() == 0){
        finalScore += 0.5;
    }
    if(myBoardCard.size() == 0){
        finalScore -= 0.5;
    }

    return finalScore;
}

class SaikiResult{
public:
    vector<Card*> useCards;
    double score;

    SaikiResult(vector<Card*> useCards, double score){
        this->useCards = useCards;
        this->score = score;
    }
};

class Game {
    vector<Card*> myHandCard;
    vector<Card*> myBoardCard;
    vector<Card*> enemyBoardCard;
    Player* me;
    Player* opponent;
    std::stringstream ss;
    vector<Game*> nextGames;

    int manaLeft;
public:
    Game(vector<Card*> myHandCard, vector<Card*> myBoardCard, vector<Card*> enemyBoardCard, Player* me, Player* opponent, string ss, int manaLeft){
        this->myHandCard = myHandCard;
        this->myBoardCard = myBoardCard;
        this->enemyBoardCard = enemyBoardCard;
        this->me = me;
        this->opponent = opponent;
        this->ss << ss;
        this->manaLeft = manaLeft;
    }

    vector<Game*> getNextGames(){
        if(nextGames.size() > 0){
            return nextGames;
        }
        else{
            // 貪欲だが、1階層目だけ展開する

            double maxScore = -99999999;
            Game* resultGame = nullptr;
            double currentBoardScore = getBoardScore(myBoardCard, enemyBoardCard, me, opponent);

            for(Card* card: myBoardCard){
                // deal yuuri trade
                if(card->getAttack() == 0 || card->getActionDone()){
                    continue;
                }
                Card* targetCard = nullptr;
                bool hasTaunt = false;
                // taunt
                for(Card* enemyCard: enemyBoardCard){
                    if(enemyCard->isGuard()){
                        hasTaunt = true;
                        Game* simulateResult = simulateTrade(card, enemyCard);
                        nextGames.push_back(simulateResult);
                    }
                }
                if (!hasTaunt) {
                    // calculate face attack value
                    Game* simulateResult = simulateTrade(card, nullptr);
                    nextGames.push_back(simulateResult);

                    for(Card* enemyCard: enemyBoardCard){
                        Game* simulateResult = simulateTrade(card, enemyCard);
                        nextGames.push_back(simulateResult);
                    }
                }
            }
        }
        return nextGames;
    }

    int originalSimulation(bool goToFace, Game** game){

        // 貪欲だが、1階層目だけ展開する

        double maxScore = -99999999;
        Game* resultGame = nullptr;

        for(Game* game: getNextGames()){
            vector<Game*> finalGames = game->getNextGames();
            for(Game* finalGame: finalGames){
                double score = finalGame->getGameBoardScore();
                if(score > maxScore){
                    maxScore = score;
                    resultGame = game;
                }
            }
        }

        // PASS
        if(resultGame == nullptr){
            resultGame = getCopy();
            resultGame->addString("PASS;");
        }
        *game = resultGame;
        return maxScore;
    }

    Game* simulation(bool goToFace){

        int maxScore = -99999999;
        Game* resultGame = nullptr;

        for(Card* card: myBoardCard){
            // deal yuuri trade
            if(card->getAttack() == 0 || card->getActionDone()){
                continue;
            }
            Card* targetCard = nullptr;
            bool hasTaunt = false;
            // taunt
            for(Card* enemyCard: enemyBoardCard){
                if(enemyCard->isGuard()){
                    hasTaunt = true;
                    Game* simulateResult = simulateTrade(card, enemyCard);
                    double score = simulateResult->getGameBoardScore();
                    if(score > maxScore){
                        maxScore = score;
                        resultGame = simulateResult;
                        if(maxScore > 9000){
                            return resultGame;
                        }
                    }
                }
            }
            if (!hasTaunt) {
                // calculate face attack value
                Game* simulateResult = simulateTrade(card, nullptr);
                double faceScore = simulateResult->getGameBoardScore();
                if(faceScore > maxScore){
                    maxScore = faceScore;
                    resultGame = simulateResult;
                    if(maxScore > 9000){
                        return resultGame;
                    }
                }

                for(Card* enemyCard: enemyBoardCard){
                    Game* simulateResult = simulateTrade(card, enemyCard);
                    double score = simulateResult->getGameBoardScore();
                    if(score > maxScore){
                        maxScore = score;
                        resultGame = simulateResult;
                        if(maxScore > 9000){
                            return resultGame;
                        }
                    }
                }
            }
        }
        
        // PASS
        if(resultGame == nullptr){
            resultGame = getCopy();
            resultGame->addString("PASS;");
        }

        return resultGame;
    }


Game* simulateTrade(Card* attacker, Card* target){
    vector<Card*> myBoardCardCopy;
    vector<Card*> enemyBoardCardCopy;
    Player* meCopy = me->getPlayerCopy();
    Player* enemyCopy = opponent->getPlayerCopy();
    std::stringstream ssCopy;
    ssCopy << ss.str(); // copy everything inside ss1's buffer to ss2's buffer
    // make copy board
    for(Card* card: myBoardCard){
        if(attacker->getID() == card->getID()){
            attacker = card->getCardCopy();
            myBoardCardCopy.push_back(attacker);
        }
        else{
            myBoardCardCopy.push_back(card);
        }
    }
    for(Card* card: enemyBoardCard){
        if(target != nullptr && target->getID() == card->getID()){
            target = card->getCardCopy();
            enemyBoardCardCopy.push_back(target);
        }
        else{
            enemyBoardCardCopy.push_back(card);
        }
    }
    if(target != nullptr){
        if(attacker->isDrain() && !target->isWard()){
            meCopy->takeDamage(-attacker->getAttack());
        }
        executeFight(attacker, target);
        // trunple
        if(attacker->isBreakThrough()){
            if(target->getDefense() < 0){
                enemyCopy->takeDamage(-target->getDefense());
            }
        }
    }
    // face
    else {
        if(attacker->isDrain()){
            meCopy->takeDamage(-attacker->getAttack());
        }
        attacker->doAction();
        enemyCopy->takeDamage(attacker->getAttack());
    }
    // jyoukyou kiin syori
    auto itr = myBoardCardCopy.begin();
    while (itr != myBoardCardCopy.end())
    {
        if ((*itr)->getDefense() <= 0)
        {
            itr = myBoardCardCopy.erase(itr);
        }
        else
        {
            itr++;
        }
    }

    itr = enemyBoardCardCopy.begin();
    while (itr != enemyBoardCardCopy.end())
    {
        if ((*itr)->getDefense() <= 0)
        {
            itr = enemyBoardCardCopy.erase(itr);
        }
        else
        {
            itr++;
        }
    }
    if(target != nullptr){
        ssCopy << "ATTACK " << attacker->getID() << " " << target->getID() << ";";
    }
    else{
        ssCopy << "ATTACK " << attacker->getID() << " " << -1 << ";";
    }
    return new Game(myHandCard, myBoardCardCopy, enemyBoardCardCopy, meCopy, enemyCopy, ssCopy.str(), manaLeft);
}


    Game* getCopy(){
        vector<Card*> myHandCardCopy;
        vector<Card*> myBoardCardCopy;
        vector<Card*> enemyBoardCardCopy;
        Player* meCopy;
        Player* opponentCopy;
        std::stringstream ssCopy;
        ssCopy << ss.str(); // copy everything inside ss1's buffer to ss2's buffer

        // make copy board
        for(Card* card: myHandCard){
            myHandCardCopy.push_back(card->getCardCopy());
        }
        for(Card* card: myBoardCard){
            myBoardCardCopy.push_back(card->getCardCopy());
        }
        for(Card* card: enemyBoardCard){
            enemyBoardCardCopy.push_back(card->getCardCopy());
        }
        meCopy = me->getPlayerCopy();
        opponentCopy = opponent->getPlayerCopy();
        return new Game(myHandCardCopy, myBoardCardCopy, enemyBoardCardCopy, meCopy, opponentCopy, ssCopy.str(), manaLeft);
    }

    double saikiUpperTime = 50;
    std::chrono::system_clock::time_point saikiTime; // 型は auto で可


    SaikiResult* saikiPlayCard(int index, vector<Card*> currentPlay, int leftMana, int boardLeft, Game* current){
        SaikiResult* result = new SaikiResult(currentPlay, 0);
        vector<Card*> playCard;

        double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(saikiTime-start).count(); //処理に要した時間をミリ秒に変換
        cerr << "time:" << elapsed << endl;
        if(elapsed > saikiUpperTime){
            result->score = -99999999;
            return result;
        }
        if(myHandCard.size() <= index){
            saikiTime = std::chrono::system_clock::now();  // 計測終了時間
            Game* copyGame = current->getCopy();
            int score = 0;
            int totalDraw = 0;
            for(Card* card: currentPlay){
                totalDraw += card->getDraw();
                // use health only cards
                if(card->getType() == 3 && card->getDefense() == 0){
                    totalDraw += 2;
                }
            }
            // simulate trade
            while(copyGame->getCommands().find("PASS") == std::string::npos){
                copyGame = copyGame->simulation(false);
            }
            result->score = copyGame->getGameBoardScore() - currentPlay.size() + totalDraw;
            return result;
        }
        result = saikiPlayCard(index + 1, currentPlay, leftMana, boardLeft, current);
        if(boardLeft == 0 && myHandCard[index]->getType() == 0){
            return result;
        }

        if(myHandCard[index]->getCost() <= leftMana){
            if(myHandCard[index]->getType() == 0){
                boardLeft --;   
            }
            vector<Card*> newPlay;
            SaikiResult* tmpResult;
            int tmpScore = 0;
            for(Card* card: currentPlay){
                newPlay.push_back(card);
            }
            Card* playCardCopy = myHandCard[index]->getCardCopy();
            newPlay.push_back(playCardCopy);
            if(playCardCopy->getType() == 0){
                boardLeft --;
            }

            Game* newBoard = current->getCopy();
            newBoard->setBestCardPlay(playCardCopy, newBoard->getGameBoardScore());
            newBoard->playCard(playCardCopy);

            tmpResult = saikiPlayCard(index + 1, newPlay, leftMana - myHandCard[index]->getCost(), boardLeft, newBoard);
            if(tmpResult->score > result->score){
                result = tmpResult;
            }
        }
        
        return result;
    }

    double getGameBoardScore(){
        return getBoardScore(myBoardCard, enemyBoardCard, me, opponent);
    }

    vector<Card*> calcBestPlayCards(bool goToFace){
        vector<Card*> firstCards;
        return saikiPlayCard(0, firstCards, manaLeft, 6 - myBoardCard.size(), this)->useCards;
    }

    void setBestCardPlay(Card* hand, int currentBoardScore){
        // health change
        Player* copyMe = me->getPlayerCopy();
        Player* copyOpponent = opponent->getPlayerCopy();
        copyMe->takeDamage(-hand->getMyHealthChange());
        copyOpponent->takeDamage(-hand->getOpponentHealthChange());
        
        if(hand->getType() == 1){
            if(myBoardCard.size() != 0){
                double maxScore = -99999;
                for(Card* targetCreature : myBoardCard){
                    vector<Card*> myBoardCardCopy;
                    for(Card* card: myBoardCard){
                        if(targetCreature->getID() == card->getID()){
                            Card* buffedCard = card->getCardCopy();
                            buffedCard->buff(hand);
                            myBoardCardCopy.push_back(buffedCard);
                        }
                        else{
                            myBoardCardCopy.push_back(card);
                        }
                    }
                    Game* current = new Game(myHandCard, myBoardCardCopy, enemyBoardCard, copyMe, copyOpponent, "", manaLeft);
                    while(current->getCommands().find("PASS") == std::string::npos){
                        current = current->simulation(false);
                    }
                    double score = current->getGameBoardScore() - currentBoardScore - 1 + hand->getDraw();
                    if(score > maxScore){
                        maxScore = score;
                        hand->setPlayScore(score);
                        std::stringstream ss;
                        ss << "USE " << hand->getID() << " " << targetCreature->getID() << ";";
                        hand->setCommand(ss.str());
                    }
                }
            }
            else{
                hand->setPlayScore(-999);
            }
        }
        else if(hand->getType() == 2){
            if(enemyBoardCard.size() != 0){
                double maxScore = -99999;
                for(Card* targetCreature : enemyBoardCard){
                    vector<Card*> enemyBoardCardCopy;
                    for(Card* card: enemyBoardCard){
                        if(targetCreature->getID() == card->getID()){
                            Card* buffedCard = card->getCardCopy();
                            buffedCard->deBuff(hand);
                            enemyBoardCardCopy.push_back(buffedCard);
                            // jyoukyou kiin syori
                            auto itr = enemyBoardCardCopy.begin();
                            itr = enemyBoardCardCopy.begin();
                            while (itr != enemyBoardCardCopy.end())
                            {
                                if ((*itr)->getDefense() <= 0)
                                {
                                    itr = enemyBoardCardCopy.erase(itr);
                                }
                                else
                                {
                                    itr++;
                                }
                            }
                        }
                        else{
                            enemyBoardCardCopy.push_back(card);
                        }
                    }
                    Game* current = new Game(myHandCard, myBoardCard, enemyBoardCardCopy, copyMe, copyOpponent, "", manaLeft);
                    while(current->getCommands().find("PASS") == std::string::npos){
                        current = current->simulation(false);
                    }
                    double score = current->getGameBoardScore() - currentBoardScore - 1 + hand->getDraw();
                    if(score > maxScore){
                        maxScore = score;
                        hand->setPlayScore(score);
                        std::stringstream ss;
                        ss << "USE " << hand->getID() << " " << targetCreature->getID() << ";";
                        hand->setCommand(ss.str());
                    }
                }
            }
            else{
                hand->setPlayScore(-999);
            }
        }
        else if(hand->getType() == 3){
            if(hand->getDefense() < 0){
                double maxScore = -99999;
                // target player score
                Player* damagedOpponent = copyOpponent->getPlayerCopy();
                damagedOpponent->takeDamage(-hand->getDefense());
                maxScore = getBoardScore(myBoardCard, enemyBoardCard, copyMe, damagedOpponent) - currentBoardScore - 1 + hand->getDraw();
                hand->setPlayScore(maxScore);
                std::stringstream ss;
                ss << "USE " << hand->getID() << " " << "-1" << ";";
                hand->setCommand(ss.str());

                for(Card* targetCreature : enemyBoardCard){
                    vector<Card*> enemyBoardCardCopy;
                    for(Card* card: enemyBoardCard){
                        if(targetCreature->getID() == card->getID()){
                            Card* buffedCard = card->getCardCopy();
                            buffedCard->deBuff(hand);
                            enemyBoardCardCopy.push_back(buffedCard);
                            // jyoukyou kiin syori
                            auto itr = enemyBoardCardCopy.begin();
                            itr = enemyBoardCardCopy.begin();
                            while (itr != enemyBoardCardCopy.end())
                            {
                                if ((*itr)->getDefense() <= 0)
                                {
                                    itr = enemyBoardCardCopy.erase(itr);
                                }
                                else
                                {
                                    itr++;
                                }
                            }
                        }
                        else{
                            enemyBoardCardCopy.push_back(card);
                        }
                    }
                    Game* current = new Game(myHandCard, myBoardCard, enemyBoardCardCopy, copyMe, copyOpponent, "", manaLeft);
                    while(current->getCommands().find("PASS") == std::string::npos){
                        current = current->simulation(false);
                    }
                    double score = current->getGameBoardScore() - currentBoardScore - 1 + hand->getDraw();
                    if(score > maxScore){
                        maxScore = score;
                        hand->setPlayScore(score);
                        std::stringstream ss;
                        ss << "USE " << hand->getID() << " " << targetCreature->getID() << ";";
                        hand->setCommand(ss.str());
                    }
                }
            }
            else{
                int score = getBoardScore(myBoardCard, enemyBoardCard, copyMe, copyOpponent) - currentBoardScore + 1 + hand->getDraw();
                hand->setPlayScore(score);
                std::stringstream ss;
                ss << "USE " << hand->getID() << " -1" << ";";
                hand->setCommand(ss.str());
            }
        }
        else if(hand->getType() == 0){
            if(hand->isCharge() && myBoardCard.size() < 6){
                vector<Card*> myBoardCardCopy;
                for(Card* card: myBoardCard){
                    myBoardCardCopy.push_back(card);
                }
                myBoardCardCopy.push_back(hand);

                Game* current = new Game(myHandCard, myBoardCardCopy, enemyBoardCard, copyMe, copyOpponent, "", manaLeft);
                while(current->getCommands().find("PASS") == std::string::npos){
                    current = current->simulation(false);
                }
                double score = current->getGameBoardScore() - currentBoardScore - 1 + hand->getDraw();
                hand->setPlayScore(score);
                std::stringstream ss;
                ss << "SUMMON " << hand->getID() << ";";
                hand->setCommand(ss.str());
            }
            else if(myBoardCard.size() < 6){
                vector<Card*> myBoardCardCopy;
                for(Card* card: myBoardCard){
                    myBoardCardCopy.push_back(card);
                }
                myBoardCardCopy.push_back(hand);
                hand->setPlayScore(getBoardScore(myBoardCardCopy, enemyBoardCard, copyMe, copyOpponent) - currentBoardScore);
                std::stringstream ss;
                ss << "SUMMON " << hand->getID() << ";";
                hand->setCommand(ss.str());
            }
            else{
                hand->setPlayScore(-999);
            }
        }
#ifdef DEBUG_PRINT
        cerr << hand->getID() << "playValueBefore=" << hand->getPlayScore() << endl;
#endif
    }

    void playCard(Card* card){
        // remove from hand
        auto itr = myHandCard.begin();
        while (itr != myHandCard.end())
        {
            if ((*itr)->getID() == card->getID())
            {
                itr = myHandCard.erase(itr);
                break;
            }
            else
            {
                itr++;
            }
        }

        // health change
        me->takeDamage(-card->getMyHealthChange());
        opponent->takeDamage(-card->getOpponentHealthChange());

        if(card->getType() == 0 && myBoardCard.size() < 6){
            ss << "SUMMON " << card->getID() << ";";
            addMyCardToBoard(card);
            // charge
            if(!card->isCharge()){
                card->doAction();
            }
            manaLeft -= card->getCost();
        }
        else if(card->getType() == 1 && card->getCommand() != ""){
            ss << card->getCommand();
            int targetID = std::atoi(split(card->getCommand(), ' ')[2].c_str());
            for(Card* target: myBoardCard){
                if(targetID == target->getID()){
                    target->buff(card);
                    break;
                }
            }
            manaLeft -= card->getCost();
        }
        else if(card->getType() == 2 && card->getCommand() != ""){
            ss << card->getCommand();
            int targetID = std::atoi(split(card->getCommand(), ' ')[2].c_str());
            for(Card* target: enemyBoardCard){
                if(targetID == target->getID()){
                    target->deBuff(card);
                    // jyoukyou kiin syori
                    auto itr = enemyBoardCard.begin();
                    itr = enemyBoardCard.begin();
                    while (itr != enemyBoardCard.end())
                    {
                        if ((*itr)->getDefense() <= 0)
                        {
                            itr = enemyBoardCard.erase(itr);
                        }
                        else
                        {
                            itr++;
                        }
                    }
                    break;
                }
            }
            manaLeft -= card->getCost();
        }
        else if(card->getType() == 3 && card->getCommand() != ""){
            ss << card->getCommand();
            int targetID = std::atoi(split(card->getCommand(), ' ')[2].c_str());
            if(targetID != -1){
                for(Card* target: enemyBoardCard){
                    if(targetID == target->getID()){
                        target->deBuff(card);
                        // jyoukyou kiin syori
                        auto itr = enemyBoardCard.begin();
                        itr = enemyBoardCard.begin();
                        while (itr != enemyBoardCard.end())
                        {
                            if ((*itr)->getDefense() <= 0)
                            {
                                itr = enemyBoardCard.erase(itr);
                            }
                            else
                            {
                                itr++;
                            }
                        }
                        break;
                    }
                }
            }
            manaLeft -= card->getCost();
        }
    }

    string getCommands(){
        return ss.str();
    }

    void addMyCardToBoard(Card* card){
        myBoardCard.push_back(card);
    }

    void addString(string str){
       ss << str;
    }
};

/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/

// mana curve
int* manaCurve = new int[13];
int idealManaCurve[13] = {2, 6, 4, 6, 3, 3, 2, 2, 1, 1, 1, 1, 1};

// by statistics
int senteIdealManaCurve[13] = {0, 0, 2, 6, 5, 5, 6, 4, 4, 2, 0, 0, 2};
int goteIdealManaCurve[13] = {5, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

// card cost counts
int catdCostCounts[13] = {7,12,33,28,30,18,15,7,5,3,0,0,2};

int* currentDeck = new int[160];
int pickedCard = 0;
int HIDDEN_SIZE = 100;
vector<vector<vector<double> > > w;
vector<vector<double> > b;

vector<vector<double> > relu(vector<vector<double> > input){
    int r = input.size();
    int c = input[0].size();
    for(int i = 0; i < r; i ++){
        for(int n = 0; n < c; n ++){
            if(input[i][n] < 0){
                input[i][n] = 0;
            }
        }
    }
    return input;
}

vector<vector<double> > sigmoid(vector<vector<double> > input){
    int r = input.size();
    int c = input[0].size();
    for(int i = 0; i < r; i ++){
        for(int n = 0; n < c; n ++){
            input[i][n] = 1/(1 + exp(-input[i][n]));
        }
    }
    return input;
}

vector<vector<double> > tanh(vector<vector<double> > input){
    int r = input.size();
    int c = input[0].size();
    for(int i = 0; i < r; i ++){
        for(int n = 0; n < c; n ++){
            input[i][n] = (1 - exp(-2 * input[i][n])) / (1 + exp(-2 * input[i][n]));
        }
    }
    return input;
}

string activation;

vector<vector<double> > applyActivation(vector<vector<double> > input){
    cerr << activation << endl;
    if(activation == "\"relu\""){
        return relu(input);
    }
    if(activation == "\"tanh\""){
        return tanh(input);
    }
    if(activation == "\"sigmoid\""){
        return sigmoid(input);
    }
    //exit(1);
}

vector<vector<double> > getOneHot(){

    vector<vector<double> > result;
    result.resize(1);
    result[0].resize(643);
    for(int i = 0; i < 160; i++){
        if(currentDeck[i] == 0){
            result[0][i * 4] = 1;
        }
        if(currentDeck[i] == 1){
            result[0][i * 4 + 1] = 1;
        }
        if(currentDeck[i] == 2){
            result[0][i * 4 + 2] = 1;
        }
        if(currentDeck[i] >= 3){
            result[0][i * 4 + 3] = 1;
        }
        /*result[0][i * 4] = 1;
        result[0][i * 4 + 1] = 1;
        result[0][i * 4 + 2] = 1;
        result[0][i * 4 + 3] = 1;*/
    }
    if(isSente){
        result[0][640] = 1;
        result[0][641] = 0;
    }
    else{
        result[0][640] = 1;
        result[0][641] = 0;
    } 
    result[0][642] = totalPick;
    return result;
}

vector<vector<double> > calcNN(){
    vector<vector<double> > inputVector = getOneHot();

    // calc matrix 1
    cerr << "layer1" << endl;
    vector<vector<double> > x1 = mulMatrix(inputVector, w[0]);
    cerr << "endmul" << endl;
    for(int i = 0; i < HIDDEN_SIZE; i ++){
        x1[0][i] += b[0][i];
    }
    //applyActivation(x1);
    x1 = relu(x1);
    // calc matrix 2
    cerr << "layer2" << endl;
    vector<vector<double> > x2 = mulMatrix(x1, w[1]);
    for(int i = 0; i < HIDDEN_SIZE; i ++){
        x2[0][i] += b[1][i];
    }
    //applyActivation(x2);
    x2 = relu(x2);
    // calc matrix 3
    cerr << "layer3" << endl;
    vector<vector<double> > x3 = mulMatrix(x2, w[2]);
    for(int i = 0; i < 160; i ++){
        x3[0][i] += b[2][i];
    }
    x3 = tanh(x3);
    //applyActivation(x3);
    return x3;
}

string modelDir;
string logFileName;
string logDirName;
string confDir;
int hidden_size = 0;

#ifdef READ_EPOCH_FILE
void readModel(){
    std::string str;

    // read activation
    std::ifstream ifs(confDir);
    if (ifs.fail()){
        std::cerr << "失敗" << std::endl;
        return;
    }
    while (getline(ifs, str)){
        str.erase(remove(str.begin(), str.end(),' '), str.end());
        if(str.substr(0, 10) == "activation"){
            activation = str.substr(11);
        }
        if(str.substr(0, 10) == "activation"){
            activation = str.substr(11);
        }
    }

    // load bias
    for(int n = 0; n < 3; n ++){
        cerr << "read bias file" << n << endl;
        string fileName;
        int size;
        if(n == 0){
            fileName = modelDir + "/Inference-Forward1-biases.csv";
        } else if(n == 1){
            fileName = modelDir + "/Inference-Forward2-biases.csv";
        } else if(n == 2){
            fileName = modelDir + "/Inference-Output-biases.csv";
        }
        std::ifstream ifs(fileName);
        if (ifs.fail()){
            std::cerr << "失敗" << std::endl;
            return;
        }
        //b[n] = new double[size];
        vector<double> oneLine;
        while (getline(ifs, str)){
            oneLine.push_back(std::atof(str.c_str()));
        }
        b.push_back(oneLine);
    }

    // load weight
    for(int n = 0; n < 3; n ++){
        cerr << "read weight file" << n << endl;
        string fileName;
        int size1, size2;
        if(n == 0){
            fileName = modelDir  + "/Inference-Forward1-weights.csv";
        } else if(n == 1){
            fileName = modelDir  + "/Inference-Forward2-weights.csv";
        } else if(n == 2){
            fileName = modelDir  + "/Inference-Output-weights.csv";
        }
        std::ifstream ifs(fileName);
        if (ifs.fail()){
            std::cerr << "失敗" << std::endl;
            return;
        }
        vector< vector <double> > weight;
        while (getline(ifs, str)){
            vector<string> result = split(str, ' ');
            vector<double> oneLine;
            for(int j = 0; j < result.size(); j ++){
                oneLine.push_back(std::atof(result[j].c_str()));
            }
            weight.push_back(oneLine);
        }
        w.push_back(weight);
        
        /*vector< vector <double> > weight;
        while (getline(ifs, str)){
            vector<string> result = split(str, ' ');
            weight.resize(result.size());
            for(int j = 0; j < result.size(); j ++){
                weight[j].push_back(std::atof(result[j].c_str()));
            }
        }
        w.push_back(weight);*/
        
    }
    cerr << "read weight done" << endl;
}
#endif

int main(int argc,char *argv[])
{

#ifdef DEBUG
    cerr << "debug mode" << endl;
#endif
#ifdef RANDOM_PICK
    cerr << "random mode" << endl;
#endif
#ifdef READ_EPOCH_FILE
    cerr << "epoch mode" << endl;
#endif
#ifdef TEKAGEN
    cerr << "tekagen mode" << endl;
#endif
#ifdef DEBUG_PRINT
    cerr << "debug print mode" << endl;
#endif


#ifdef DEBUG
    logDirName = argv[1];
#endif

#ifdef READ_EPOCH_FILE
    modelDir = argv[2];
    confDir = argv[3];
    readModel();
    for(int i = 0; i < 160; i ++){
        currentDeck[i] = 1;
    }
    vector<vector<double> > nn = calcNN();
    for(int i = 0; i < 160; i ++){
        cerr << nn[0][i] << endl;
    }
#endif

    for(int i = 0; i < 160; i ++){
        currentDeck[i] = 0;
    }
    for(int i = 0; i < 13; i ++){
        manaCurve[i] = 0;
    }
    // game loop
    while (1) {
        vector<Card*> myHandCard;
        vector<Card*> myBoardCard;
        vector<Card*> enemyBoardCard;
        Player* me;
        Player* opponent;
        for (int i = 0; i < 2; i++) {
            int playerHealth;
            int playerMana;
            int playerDeck;
            int playerRune;
            cin >> playerHealth >> playerMana >> playerDeck >> playerRune; cin.ignore();
            cerr << playerHealth << " " << playerMana << " " << playerDeck << " " << playerRune << endl;
            if(i == 0){
                me = new Player(playerHealth, playerMana, playerDeck, playerRune);
            }
            else {
                opponent = new Player(playerHealth, playerMana, playerDeck, playerRune);
            }
        }
        int opponentHand;
        cin >> opponentHand; cin.ignore();
        int cardCount;
        cin >> cardCount; cin.ignore();
        for (int i = 0; i < cardCount; i++) {
            int cardNumber;
            int instanceId;
            int location;
            int cardType;
            int cost;
            int attack;
            int defense;
            string abilities;
            int myHealthChange;
            int opponentHealthChange;
            int cardDraw;
            cin >> cardNumber >> instanceId >> location >> cardType >> cost >> attack >> defense >> abilities >> myHealthChange >> opponentHealthChange >> cardDraw; cin.ignore();
            cerr << cardNumber << " " << instanceId << " " << location << " " << cardType << " " << cost << " " << attack << " " << defense << " " << abilities << " " << myHealthChange << " " << opponentHealthChange << " " << cardDraw << endl;
            Card* card = new Card(cardNumber, instanceId, location, cardType, cost, attack, defense, abilities, myHealthChange, opponentHealthChange, cardDraw, false);
            if(location == 0){
                myHandCard.push_back(card);
            }
            else if (location == 1){
                myBoardCard.push_back(card);
            }
            else if(location == -1){
                enemyBoardCard.push_back(card);
            }
        }

        start = std::chrono::system_clock::now(); // 計測開始時間

        // while draft phase
        Card* lowestCard = nullptr;

        if(me->getDeck() == opponent->getDeck()){
            isSente = true;
        }
        else{
            isSente = false;
        }

        int lowestIndex = -1;
        double maxScore = -9999999;
        int i = 0;
        double expectedManaCurve[13] = {0,0,0,0,0,0,0,0,0,0,0,0,0};
        for(int n = 0; n < 13; n ++){
            expectedManaCurve[n] = manaCurve[n] + (30 - pickedCard - 1) * ((double)catdCostCounts[n] / 160);
#ifdef DEBUG_PRINT
            cerr << "mana" << n << ":" << manaCurve[n] << endl;
            cerr << "expedtedmana" << n << ":" << expectedManaCurve[n] << endl;
#endif
        }


        // think about mana curve
        if(me->getMana() == 0){
            for(Card* card: myHandCard){
                /*double score;
                if(me->getDeck() == opponent->getDeck()){
                    score = senteManaCurve[card->getCost()][((int)expectedManaCurve[card->getCost()]) + 1] -  senteManaCurve[card->getCost()][((int)expectedManaCurve[card->getCost()])];
                }
                else{
                    score = goteManaCurve[card->getCost()][((int)expectedManaCurve[card->getCost()]) + 1] -  goteManaCurve[card->getCost()][((int)expectedManaCurve[card->getCost()])];
                }
                cerr << score << endl;
#ifndef TEKAGEN
                if(me->getDeck() == opponent->getDeck()){
                    //score += senteCardValues[card->getCardNumber() - 1] * 5;
                    score += senteCardWinrate[card->getCardNumber() - 1][currentDeck[card->getCardNumber() - 1] + 1] - senteCardWinrate[card->getCardNumber() - 1][currentDeck[card->getCardNumber() - 1]];
                }
                else{
                    score += goteCardWinrate[card->getCardNumber() - 1][currentDeck[card->getCardNumber() - 1] + 1] - goteCardWinrate[card->getCardNumber() - 1][currentDeck[card->getCardNumber() - 1]];
                    //score += goteCardValues[card->getCardNumber() - 1] * 5;
                }
                cerr << score << endl;
                //score = cardWinrate[card->getCardNumber() - 1][currentDeck[card->getCardNumber() - 1] + 1] - cardWinrate[card->getCardNumber() - 1][currentDeck[card->getCardNumber() - 1]];
#endif*/
                double score = idealManaCurve[card->getCost()] - expectedManaCurve[card->getCost()];
#ifndef TEKAGEN

                score += cardValues[card->getCardNumber() - 1] * 200;
                /*if(me->getDeck() != opponent->getDeck()){
                    score += senteCardValues[card->getCardNumber() - 1] * 200;
                }
                else{
                    score += goteCardValues[card->getCardNumber() - 1] * 200;
                }*/
                //score = cardWinrate[card->getCardNumber() - 1][currentDeck[card->getCardNumber() - 1] + 1] - cardWinrate[card->getCardNumber() - 1][currentDeck[card->getCardNumber() - 1]];
#endif
#ifdef READ_EPOCH_FILE
                score = calcNN()[0][card->getCardNumber() - 1];
#endif
                /*if(card->getType() != 0){
                    score = -9999;
                }*/
                cerr << maxScore << endl;
                if(lowestCard == nullptr || maxScore < score){
                    lowestCard = card;
                    lowestIndex = i;
                    maxScore = score;
                }
                i ++;
            }
#ifdef RANDOM_PICK
            std::random_device rd;
            std::mt19937 mt(rd());
            std::uniform_int_distribution<int> dice(0,10);
            int rnd = dice(mt);
            if(rnd <= 2){
                lowestIndex = rnd;
                lowestCard = myHandCard[lowestIndex];
            }
#endif

            cerr << lowestIndex << endl;
            cout << "PICK " << lowestIndex << endl;
            totalPick ++;

#ifdef DEBUG
            ofstream outputfile(logDirName, ios::app);
            for(int i = 0; i < 160; i++){
                outputfile << currentDeck[i] << " ";
            }
            outputfile << endl;
            for(Card* card: myHandCard){
                outputfile << card->getCardNumber() - 1 << " ";
            }
            outputfile << endl;
            outputfile << lowestCard->getCardNumber() - 1 << endl;
            outputfile.close();
#endif DEBUG

            currentDeck[lowestCard->getCardNumber() - 1]++;
            manaCurve[lowestCard->getCost()]++;
            pickedCard ++;
        }
        else{
            // judge leathal
            bool goToFace = false;
            int totalAttack = 0;
            int totalDefence = 0;
            for(Card* card: myBoardCard){
                totalAttack += card->getAttack();
            }
            for(Card* card: enemyBoardCard){
                totalDefence += card->getDefense();
            }
            if(totalAttack * 2 > opponent->getHealth() + totalDefence){
                goToFace = true;
            }
            
            // battle phase
            cerr << goToFace << endl;
            Game* current = new Game(myHandCard, myBoardCard, enemyBoardCard, me, opponent, "", me->getMana());
            
            // make play card score 
            vector<Card*> beforePlayCards = current->calcBestPlayCards(goToFace);
            for(Card* card: beforePlayCards){
                cerr << "beforePlay:" << card->getCommand() << endl;
                current->playCard(card);
            }


            vector<Game*> history;
            vector<int> scoreHistory;
            history.push_back(current);
            scoreHistory.push_back(current->getGameBoardScore());
            while(current->getCommands().find("PASS") == std::string::npos){
                Game* next;
                int score = current->originalSimulation(goToFace, &next);
                history.push_back(next);
                scoreHistory.push_back(score);
                current = next;
                //cerr << current->getCommands() << endl;
            }

            // trace
            /*for(int i = history.size() - 1; i > 0; i --){
                if(scoreHistory[i] - scoreHistory[i - 1] > 0){
                    current = history[i - 1];
                    current->addString("PASS;");
                }
                else{
                    break;
                }
            }*/



            int passIndex = current->getCommands().find("PASS");
            
            vector<Card*> playCards;

            // play cards untill no more want to play
            playCards = current->calcBestPlayCards(false);
            while(playCards.size() > 0){
                for(Card* card: playCards){
                    current -> playCard(card);
                }
                playCards = current->calcBestPlayCards(false);
            }

            // use chage cards
            current = current->simulation(goToFace);
            while(current->getCommands().find("PASS", passIndex + 1) == std::string::npos){
                current = current->simulation(goToFace);
                cerr << current->getCommands() << endl;
            }

            std::chrono::system_clock::time_point  end; // 型は auto で可
            end = std::chrono::system_clock::now();  // 計測終了時間
            double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end-start).count(); //処理に要した時間をミリ秒に変換

            cout << current->getCommands() << "PASS " << elapsed << "ms;" << endl;
        }

        // Write an action using cout. DON'T FORGET THE "<< endl"
        // To debug: cerr << "Debug messages..." << endl;

       
    }
}